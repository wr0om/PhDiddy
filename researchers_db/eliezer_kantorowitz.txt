Recent papers for Eliezer Kantorowitz:

2017: Semantic User Interface Controls
Abstract: Many years ago my student Yoram Hazan compared two different graphical user interfaces (GUIs) [3]. One GUI was easy-tounderstand and the other was difficult-to–understand. Those who used the difficult-to-understand GUI got angry or frustrated in some experimental situations. Those who used the easy-tounderstand GUI asked sometimes after completing a task of the experiments, whether they may try to do the task in a different way. These user requests suggest both their satisfaction with the application and the possibility of exploiting it in a creative and productive way. It is therefore important to construct both the code of the application and its user interface (UI), such that the human user may easily understand the application. In order to

2016: Two Step User Interface Design
Abstract: This paper presents an experimental system to support a two-step User-Interface (UI) design method. The semantic user interface may be useful for research and student training of issues related to the user interface by focusing on some cognitive ergonomic aspects of UI usage.

2015: A tool for research and training in Cognitive ergonomic system design
Abstract: The subject of this demo is a tool, under development, for training undergraduate students in system design. The tool supports the requirement elicitation and system specification phases of system design. The tool permits specifications in natural languages, such that stakeholders not familiar with computer programming and formal specifications may participate in the development and validation of the requirements and the specifications. A GUI may be produced from verbal specifications enabling think aloud evaluations of the designed system. The tool is intended for undergraduate students who do not have the time required for learning the use of feature rich industrial software tools. Our tool has few features making it easy to learn and easy to use, which should enable the students to invest most of their resources in the essence of their exercises.

2014: Low Cost User Experience (UX) Design
Abstract: Designing a computer application to provide a satisfactory user experience (UX) is often labor intensive. This workshop focuses on reducing these labor costs. With possible low cost design methods, it may be affordable to compare a reasonable number of different design alternatives and select the best one. Possible low cost design methods may thus facilitate the design of quality UX. Possible low costs methods may also facilitate empirical cognitive ergonomic research involving a considerable number of cases.
 In order to achieve its goals, the workshop will consider the labor costs of different UX design methods. The participants of the workshop are invited to submit position papers on UX design costs issues. After the presentation of the position papers, the workshop will discuss the findings and summarize its observations and possible recommendations.
 Examples of topics of possible position paper:
 • UX oriented requirements elicitation and task analysis. By UX, orientation is meant for example avoiding features that the end users may misunderstand, developing a cognitive coherent model of the application and validating the UX of this model on prototypes.
 • Labor efficient UX evaluation methods, e.g. economic think aloud techniques, automatic logging and analysis of user actions and fast prototyping techniques facilitating comparison of the UX of different solutions.
 • Software architectures where it is quite easy to modify the user interface. This may facilitate a gradual UX improvement process.
 • Critical review of published recommendation for user interface design, e.g. user interface design patterns (interaction design patterns).
 • Experience reports from industry and education. What were the labor costs lessons learned?
 • Comparison of different methods for doing the same thing from a labor costs point of view.
 • Efficient stakeholder participation methods.
 • Agile development issues.
 • The psychology and sociology of the UX design team. What team member qualifications and work methods are most appropriate?

2013: Ergonomics of dependable and of safety critical systems
Abstract: System failures are in some applications (e.g., banking) difficult to accept and have resulted in the development of highly dependable systems. A special class of these systems regards the safety critical systems, whose operation involves risks for the health or the life of humans (e.g., air traffic control systems). This workshop considers the design of the user interfaces of such systems. Some of these user interfaces must enable coping with cognitively demanding situations. The workshop will, in addition, consider the process of designing these systems. The possibly most difficult part of the design regards the attempt to identify all the possible critical cases. This may require the participation of different kinds of experts and employing methods designed for uncovering difficult-to-detect critical cases. The design of dependable systems may thus involve a most demanding kind of computer-supported cooperative work (CSCW).

2011: Verbal use case specifications for informal requirements elicitation
Abstract: Requirements elicitation is considered by some to be the most difficult and most critical phase of system development. Some of the most difficult to correct bugs are due to deficiencies in the requirement specifications. Requirements elicitation is basically an informal process where the insights of the stakeholders and end users are most useful. Dan Beery claims [1] that it is also useful to have persons that are not familiar with the problem domain in the requirement elicitation team. Such domain ignorant people may raise questions outside the train of thoughts of the domain experts. The requirements elicitation team need also computer scientists to evaluate the technical feasibility of the requirements. The team that elicits the requirements and specify the system may thus be composed of persons having very different backgrounds. A productive collaboration between such team members is in itself an interesting challenge.

2007: Estimating the Required Code Inspection Team Size
Abstract: Code inspection is considered an efficient method for detecting faults in software code documents. The number of faults not detected by inspection should be small. Several methods have been suggested for estimating the number of undetected faults. These methods include the fault injection method that is considered to be quite laborious, capture recapture methods that avoid the problems of code injection and the Detection Profile Method for cases where capture recapture methods do not provide sufficient accuracy. The Kantorowitz estimator is based on a probabilistic model of the inspection process and enables the estimating the number of inspectors required to detect a specified fraction of all the faults of a document as well as the number of undetected faults. This estimator has proven to be satisfactory in inspection of user requirements documents. The experiments reported in this study suggest that it is also useful for code inspection.

2006: Using Semantic Component Interfaces in Software Engineering Training
Abstract: Laboratories for training students in software development involve a considerable coding effort, reducing the complexity of the exercises that are possible in the available lab time. In order to reduce this coding effort our laboratory employed the component framework WebSI. An application developed with WebSI is composed of application logic (AL) component and an interaction style (IS) component, containing code for producing and managing the graphical user interface (GUI). In the laboratory the students wrote only the AL component, while the instructor provided a number of ready-made different IS components. If the student didn't like the produced GUI, she could simply exchange the IS component with one that produces a GUI that is more to her liking. The exchange of an IS component is possible since all IS components employ the same abstract semantic interface, which does not specify the geometric and other properties of the GUI to be produced. Changing components is fast, as no compilation is required. The time the students saved by using ready-made IS components was invested in requirement elicitation and specifications, which had a beneficial effect on the usability of the student projects.

2005: Use-case components for interactive information systems
Abstract: None

2005: Estimating the number of faults remaining in software code documents inspected with iterative code reviews
Abstract: Code review is considered an efficient method for detecting faults in a software code document. The number of faults not detected by the review should be small. Current methods for estimating this number assume reviews with several inspectors, but there are many cases where it is practical to employ only two inspectors. Sufficiently accurate estimates may be obtained by two inspectors employing an iterative code review (ICR) process. This paper introduces a new estimator for the number of undetected faults in an ICR process, so the process may be stopped when a satisfactory result is estimated. This technique employs the Kantorowitz estimator for N-fold inspections, where the N teams are replaced by N reviews. The estimator was tested for three years in an industrial project, where it produced satisfactory results. More experiments are needed in order to fully evaluate the approach.

2004: A framework for information systems construction facilitating HCI experimentation
Abstract: None

2003: A use case-oriented user interface framework
Abstract: Interactive computer applications are sometimes specified by their use cases. These specifications are often formulated in a natural language to enable domain experts, that are not familiar with formal notations, to validate their usefulness. A use case-oriented application framework facilitates manual translation of the natural language specifications into high level code, whose equivalence with the specifications is easy to establish. The purpose is to reduce the costs of both verification and coding. A previous framework of this kind achieved its high level by providing most of the graphical user interface (GUI) code. However, the automatically produced GUI was not always satisfactory. We report on advances achieved by more intelligent user interface construction framework. We introduce a new kind of user interface component, called use case displayer, that enables an almost automatic generation of the user interface of the entire application. The framework was tested in a student laboratory, where it reduced the implementation effort, leaving most of the time (10 of the 15 available weeks) for requirements elicitation, specification development and validation. As expected, the designs produced had a higher level of usability than found in comparable student laboratories. At this stage the framework is useful for student laboratories. More research is required to assess its suitability for industrial use.

2002: A Specification-Oriented Framework for Information System User Interfaces
Abstract: None

2001: A Method for Evaluation of the Performance of Requirements Inspections
Abstract: A new improved model is introduced for the performance of inspectors of user requirements documents. The model, which is based on a linearity assumption employs only two non-dimensional metrics in the [0;1] interval. They characterise the error detection ability of the inspectors and their domain knowledge level. It is our experience that one learns to reason with these two metrics. The application of the model is demonstrated with an analysis of which kind of inspectors, low salaried students or experienced high salaried engineers, will perform a specified inspection most economically.

1999: Use Cases and Task Analysis
Abstract: None

1999: Some Observations on the Relationship between Tasks Use Cases Scenarios and Requirements Models
Abstract: None

1998: Is Extension Complexity a Fundamental Software Metric?
Abstract: The concepts of implementation and extension complexities were developed in connection with an object oriented reengineering of a legacy CAD system [KA97]. These concepts consider a software system as an implementation of a number of different algorithms. Ideally, an algorithm in an object oriented (O-O) system is implemented by a single method that only processes data in its own object. Such an algorithm is desirable because it cannot cause coupling between different objects. It is possible to design and test the method that implements such an algorithm without knowing anything about the other object types (classes). The costs of implementing and testing such an algorithm are therefore usually modest. Higher implementation and testing costs may be expected in algorithms that process data in a number of objects belonging to different object types. The reason is that the implementers must have the data structures of these different object types in their mind while implementing the algorithm. Furthermore, an algorithm involving different object types will typically employ a number of different methods in these different object types. The implementers must therefore also consider all of these different methods during the implementation. It may therefore be assumed that the cognitive load on the mind of the implementers is generally higher with algorithms involving a number of different object types. The costs of implementing and testing an algorithm are therefore assumed to be related to the number of different object types involved. In order to express this the following definitions were introduced:

1997: On Implementation and Extension Complexities
Abstract: None

1997: The performance of the N-fold requirement inspection method
Abstract: None

1997: Algorithm Simplification through Object Orientation
Abstract: The object‐oriented (O‐O) approach is claimed to have a number of advantages. Some support to these claims appeared during an O‐O redesign of a legacy CAD system. A surprisingly simple and efficient solution algorithm was discovered for a change propagation problem. The analysis of the case employs the new concepts of implementation and extension complexity, which indicate the amount of code (software costs) required for the implementation and for later extensions. These two complexities are functions of the problem complexity, expressed by the number N of object types employed to model the problem domain. Moving from the old system to the new O‐O system reduced the implementation complexity from O(N2) to O(N); the extension complexity is reduced from O(N) to O(1). The two systems have the same space and time complexities. The CAD system is employed for designing structures composed of parts. The O‐O analysis attempts to analyse each part type separately, which proved to be possible. The corresponding N different object types can therefore be developed independently of each other. The top down analysis employed for the old algorithm did not discover the simple architecture, because it is not geared to look for this kind of solution. Instead it analyses the N2 different change propagation cases. The methodical search for independent modules is an important reason for preferring O‐O analysis. © 1997 by John Wiley & Sons, Ltd.

