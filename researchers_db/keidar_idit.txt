Recent papers for Keidar Idit:

2024: KV-Tandem - a Modular Approach to Building High-Speed LSM Storage Engines
Abstract: We present~\emph{KV-Tandem}, a modular architecture for building LSM-based storage engines on top of simple, non-ordered persistent key-value stores (KVSs). KV-Tandem enables advanced functionalities such as range queries and snapshot reads, while maintaining the native KVS performance for random reads and writes. Its modular design offers better performance trade-offs compared to previous KV-separation solutions, which struggle to decompose the monolithic LSM structure. Central to KV-Tandem is~\emph{LSM bypass} -- a novel algorithm that offers a fast path to basic operations while ensuring the correctness of advanced APIs. We implement KV-Tandem in \emph{XDP-Rocks}, a RocksDB-compatible storage engine that leverages the XDP KVS and incorporates practical design optimizations for real-world deployment. Through extensive microbenchmark and system-level comparisons, we demonstrate that XDP-Rocks achieves 3x to 4x performance improvements over RocksDB across various workloads. XDP-Rocks is already deployed in production, delivering significant operator cost savings consistent with these performance gains.

2023: Nova: Safe Off-Heap Memory Allocation and Reclamation
Abstract: In recent years, we begin to see Java-based systems embrace off-heap allocation for their big data demands. As of today, these system rely on simple ad-hoc garbage-collection solutions, which restrict the usage of off-heap data. This paper introduces the abstraction of safe off-heap memory allocation and reclamation (SOMAR) , a thread-safe memory allocation and reclamation scheme for off-heap data in otherwise managed environments. SOMAR allows multi-threaded Java programs to use off-heap memory seamlessly. To realize this abstraction, we present Nova, Novel Off-heap Versioned Allocator , a lock-free SOMAR implementation. Our experiments show that Nova can be used to store off-heap data in Java data structures with better performance than ones managed by Java‚Äôs automatic GC. We further integrate Nova into the open-source Oak concurrent map library, which allows Oak to reclaim keys while the data structure is being accessed.

2023: Subquadratic Multivalued Asynchronous Byzantine Agreement WHP
Abstract: There have been several reductions from multivalued consensus to binary consensus over the past 20 years. To the best of our knowledge, none of them solved it for Byzantine asynchronous settings. In this paper, we close this gap. Moreover, we do so in subquadratic communication, using newly developed subquadratic binary Byzantine Agreement techniques.

2022: Cordial Miners: A Family of Simple, Efficient and Self-Contained Consensus Protocols for Every Eventuality
Abstract: Cordial Miners is a family of simple, eÔ¨Écient, self-contained, Byzantine Atomic Broadcast protocols, with optimal instances for asynchrony and eventual synchrony. Its simplicity-cum-eÔ¨Éciency stems from using the blocklace‚Äîa partially-ordered generalization of the totally-ordered blockchain‚Äîfor all key algorithmic tasks, including block dissemination, equivocation exclusion, leader Ô¨Ånality, block ordering, and for the identiÔ¨Åcation and exclusion of faulty miners. The algorithm employs piecemeal topological sort of the partially-ordered blocklace into a totally-ordered sequence of blocks, excluding equivocations as well as the Byzantine miners perpetrating them along the way. The conversion process is monotonic in that the output sequence only extends as the input blocklace increases, which implies ( i ) safety ‚Äì the outputs of two correct miners are consistent (one is a preÔ¨Åx of the other), and ( ii ) Ô¨Ånality ‚Äì any output of a correct miner is Ô¨Ånal. The Cordial Miners protocols are self-contained, using simple all-to-all block communication to realize blocklace-based dissemination and equivocation exclusion. They promptly excommunicate equivocating Byzantine miners, and thus can reduce the supermajority required for Ô¨Ånality and eventually enjoy equivocation-free execution. In contrast, state-of-the-art protocols such as DAG-Rider and its successor Bullshark employ reliable broadcast as a black box and thus allow Byzantine miners to participate and equivocate indeÔ¨Ånitely. We present two instances of the protocol family: One for the eventual synchrony model, employing deterministic/predicted leader selection and 3 rounds of communication to leader Ô¨Ånality in the good case, which is three-quarters of the latency of state-of-the-art protocols. The second for the asynchrony model, employing retroactive random leader selection, 6 rounds to leader Ô¨Ånality in the good case, and 9 rounds in the expected case, which is half the latency of state-of-the-art protocols in the good case and three-quarters of their latency in the expected case. In both protocols, message complexity is the same as the state-of-the-art.

2022: SwiSh: Distributed Shared State Abstractions for Programmable Switches
Abstract: We design and evaluate SwiSh , a distributed shared state management layer for data-plane P4 programs. SwiSh enables running scalable stateful distributed network functions on programmable switches entirely in the data-plane. We explore several schemes to build a shared variable abstraction, which differ in consistency, performance, and in-switch implementation complexity. We introduce the novel Strong Delayed-Writes (SDW) protocol which offers consistent snapshots of shared data-plane objects with semantics known as ùëü -relaxed strong linearizability, enabling implementation of distributed concurrent sketches with precise error bounds. We implement strong, eventual, and SDW consistency protocols in ToÔ¨Åno switches, and compare their performance in microbenchmarks and three realistic network functions, NAT, DDoS detector, and rate limiter. Our results show that the distributed state management in the data plane is practical, and outperforms centralized solutions by up to four orders of magnitude in update throughput and replication latency.

2022: On Payment Channels in Asynchronous Money Transfer Systems
Abstract: Money transfer is an abstraction that realizes the core of cryptocurrencies. It has been shown that, contrary to common belief, money transfer in the presence of Byzantine faults can be implemented in asynchronous networks and does not require consensus. Nonetheless, existing implementations of money transfer still require a quadratic message complexity per payment, making attempts to scale hard. In common blockchains, such as Bitcoin and Ethereum, this cost is mitigated by payment channels implemented as a second layer on top of the blockchain allowing to make many off-chain payments between two users who share a channel. Such channels only require on-chain transactions for channel opening and closing, while the intermediate payments are done off-chain with constant message complexity. But payment channels in-use today require synchrony, therefore they are inadequate for asynchronous money transfer systems. In this paper, we provide a series of possibility and impossibility results for payment channels in asynchronous money transfer systems. We first prove a quadratic lower bound on the message complexity of on-chain transfers. Then, we explore two types of payment channels, unidirectional and bidirectional. We define them as shared memory abstractions and prove that in certain cases they can be implemented as a second layer on top of an asynchronous money transfer system whereas in other cases it is impossible.

2022: Make Every Word Count: Adaptive Byzantine Agreement with Fewer Words
Abstract: Byzantine Agreement is a key component in many distributed systems. While Dolev and Reischuk have proven a long time ago that quadratic communication complexity is necessary for worst-case runs, the question of what can be done in practically common runs with fewer failures remained open. In this paper we present the first Byzantine Broadcast algorithm with $O(n(f+1))$ communication complexity, where $0\leq f\leq t$ is the actual number of process failures in a run. And for BA with strong unanimity, we present the first optimal-resilience algorithm that has linear communication complexity in the failure-free case and a quadratic cost otherwise.

2022: Quancurrent: A Concurrent Quantiles Sketch
Abstract: Sketches are a family of streaming algorithms widely used in the world of big data to perform fast, real-time analytics. A popular sketch type is Quantiles, which estimates the data distribution of a large input stream. We present Quancurrent, a highly scalable concurrent Quantiles sketch. Quancurrent's throughput increases linearly with the number of available threads, and with 32 threads, it reaches an update speedup of 12x and a query speedup of 30x over a sequential sketch. Quancurrent allows queries to occur concurrently with updates and achieves an order of magnitude better query freshness than existing scalable solutions.

2022: Fast Concurrent Data Sketches
Abstract: Data sketches are approximate succinct summaries of long data streams. They are widely used for processing massive amounts of data and answering statistical queries about it. Existing libraries producing sketches are very fast, but do not allow parallelism for creating sketches using multiple threads or querying them while they are being built. We present a generic approach to parallelising data sketches efficiently and allowing them to be queried in real time, while bounding the error that such parallelism introduces. Utilising relaxed semantics and the notion of strong linearisability, we prove our algorithm‚Äôs correctness and analyse the error it induces in some specific sketches. Our implementation achieves high scalability while keeping the error small. We have contributed one of our concurrent sketches to the open-source data sketches library.

2022: Make Every Word Count: Adaptive BA with Fewer Words
Abstract: Byzantine Agreement is a key component in many distributed systems. While Dolev and Reischuk have proven a long time ago that quadratic communication complexity is necessary for worst-case runs, the question of what can be done in practically common runs withfewerfailures remained open. In this paper we present the Ô¨Årst Byzantine Broadcast algorithm with ùëÇ ( ùëõ ( ùëì + 1 )) communication complexity, where 0 ‚â§ ùëì ‚â§ ùë° is the actual number of process failures in a run. And for BA with strong unanimity, we present the Ô¨Årst optimal-resilience algorithm that has linear communication complexity in the failure-free case and a quadratic cost otherwise. CCS Concepts

2022: DSON: JSON CRDT Using Delta-Mutations For Document Stores
Abstract: 
 We propose DSON, a space efficient Œ¥-based CRDT approach for distributed JSON document stores, enabling high availability at a global scale, while providing
 strong
 eventual consistency guarantees. We define the semantics of our CRDT based approach formally, and prove its correctness and convergence. Previous approaches optimize for collaborative document editing and store metadata proportional to the number of updates to a document, which is not acceptable for long lived document management. The metadata stored with our approach is bounded by
 O
 (
 k
 2
 D
 +
 n
 log
 n
 ), where
 n
 is the number of replicas,
 D
 is the number of document elements, and
 k
 ‚â§
 n
 is the number of concurrent document updates. We also implement our approach[37] and demonstrate its space efficiency empirically. Experimental analysis shows that the metadata stored is typically significantly less than the worst case. This provides the basis for robust highly available distributed document stores with well defined semantics and safety guarantees, relieving application developers from the burden of conflict resolution.


2022: Cordial Miners: Fast and Efficient Consensus for Every Eventuality
Abstract: Cordial Miners are a family of efficient Byzantine Atomic Broadcast protocols, with instances for asynchrony and eventual synchrony. They improve the latency of state-of-the-art DAG-based protocols by almost 2X and achieve optimal good-case complexity of O(n) by forgoing Reliable Broadcast as a building block. Rather, Cordial Miners use the blocklace -- a partially-ordered counterpart of the totally-ordered blockchain data structure -- to implement the three algorithmic components of consensus: Dissemination, equivocation-exclusion, and ordering.

2022: Cordial Miners: Blocklace-Based Ordering Consensus Protocols for Every Eventuality
Abstract: Cordial Miners are a family of efficient Byzantine Atomic Broad-cast protocols, with instances for asynchrony and eventual synchrony. Their efficiency‚Äîalmost half the latency of state-of-the-art DAG-based protocols‚Äîstems from not using reliable broadcast as a building block. Rather, Cordial Miners use the blocklace‚Äîa partially-ordered generalization of the totally-ordered blockchain‚Äîfor all algorithmic tasks required for ordering consensus: Dissemination, equivocation-exclusion, and ordering.

2021: Tame the Wild with Byzantine Linearizability: Reliable Broadcast, Snapshots, and Asset Transfer
Abstract: We formalize Byzantine linearizability, a correctness condition that specifies whether a concurrent object with a sequential specification is resilient against Byzantine failures. Using this definition, we systematically study Byzantine-tolerant emulations of various objects from registers. We focus on three useful objects -- reliable broadcast, atomic snapshot, and asset transfer. We prove that there is an $f$-resilient implementation of such objects from registers with $n$ processes $f<\frac{n}{2}$.

2021: All You Need is DAG
Abstract: We present DAG-Rider, the first asynchronous Byzantine Atomic Broadcast protocol that achieves optimal resilience, optimal amortized communication complexity, and optimal time complexity. DAG-Rider is post-quantum safe and ensures that all values proposed by correct processes eventually get delivered. We construct DAG-Rider in two layers: In the first layer, processes reliably broadcast their proposals and build a structured Directed Acyclic Graph (DAG) of the communication among them. In the second layer, processes locally observe their DAGs and totally order all proposals with no extra communication.

2021: Byzantine Agreement with Less Communication
Abstract: The development of reliable distributed systems often relies on Byzantine Agreement (BA) [26]. In this problem, a set of correct processes aim to reach a common decision, despite the presence of malicious ones. BA has been around for four decades, yet practical use-cases for it in large-scale systems have emerged only in the last decade. One major application for BA is cryptocurrencies. For example, Bitcoin [30], the rst cryptocurrency, requires a large set of users to agree on the state of the blockchain. Since Bitcoin is a real currency with real value, the need to protect it against Byzantine users is crucial. Following Bitcoin, many other blockchains and FinTech platforms have emerged, e.g., [6,21,30,36]. Consequently, an efficient implementation, in terms of communication, has become one of the main foci of BA solutions.

2020: Not a COINcidence: Sub-Quadratic Asynchronous Byzantine Agreement WHP
Abstract: King and Saia were the first to break the quadratic word complexity bound for Byzantine Agreement in synchronous systems against an adaptive adversary, and Algorand broke this bound with near-optimal resilience (first in the synchronous model and then with eventual-synchrony). Yet the question of asynchronous sub-quadratic Byzantine Agreement remained open. To the best of our knowledge, we are the first to answer this question in the affirmative. A key component of our solution is a shared coin algorithm based on a VRF. A second essential ingredient is VRF-based committee sampling, which we formalize and utilize in the asynchronous model for the first time. Our algorithms work against a delayed-adaptive adversary, which cannot perform after-the-fact removals but has full control of Byzantine processes and full information about communication in earlier rounds. Using committee sampling and our shared coin, we solve Byzantine Agreement with high probability, with a word complexity of $\widetilde{O}(n)$ and $O(1)$ expected time, breaking the $O(n^2)$ bit barrier for asynchronous Byzantine Agreement.

2020: Scalable top-k retrieval with Sparta
Abstract: Many big data processing applications rely on a top-k retrieval building block, which selects (or approximates) the k highest-scoring data items based on an aggregation of features. In web search, for instance, a document's score is the sum of its scores for all query terms. Top-k retrieval is often used to sift through massive data and identify a smaller subset of it for further analysis. Because it filters out the bulk of the data, it often constitutes the main performance bottleneck. Beyond the rise in data sizes, today's data processing scenarios also increase the number of features contributing to the overall score. In web search, for example, verbose queries are becoming mainstream, while state-of-the-art algorithms fail to process long queries in real-time. We present Sparta, a practical parallel algorithm that exploits multi-core hardware for fast (approximate) top-k retrieval. Thanks to lightweight coordination and judicious context sharing among threads, Sparta scales both in the number of features and in the searched index size. In our web search case study on 50M documents, Sparta processes 12-term queries more than twice as fast as the state-of-the-art. On a tenfold bigger index, Sparta processes queries at the same speed, whereas the average latency of existing algorithms soars to be an order-of-magnitude larger than Sparta's.

2020: Brief Announcement: Not a COINcidence: Sub-Quadratic Asynchronous Byzantine Agreement WHP
Abstract: King and Saia were the first to break the quadratic word complexity bound for Byzantine Agreement in synchronous systems against an adaptive adversary, and Algorand broke this bound with near-optimal resilience (first in the synchronous model and then with eventual-synchrony). Yet the question of asynchronous sub-quadratic Byzantine Agreement remained open. To the best of our knowledge, we are the first to answer this question in the affirmative. A key component of our solution is a shared coin algorithm based on a VRF. A second essential ingredient is VRF-based committee sampling, which we formalize and utilize in the asynchronous model for the first time. Our algorithms work against a delayed-adaptive adversary, which cannot perform after-the-fact removals but has full control of Byzantine processes and full information about communication in earlier rounds. Using committee sampling and our shared coin, we solve Byzantine Agreement with high probability, with a word complexity of √ï(n) and O(1) expected time, breaking the O(n2) bit barrier for asynchronous Byzantine Agreement.

2020: Expected Linear Round Synchronization: The Missing Link for Linear Byzantine SMR
Abstract: State Machine Replication (SMR) solutions often divide time into rounds, with a designated leader driving decisions in each round. Progress is guaranteed once all correct processes synchronize to the same round, and the leader of that round is correct. Recently suggested Byzantine SMR solutions such as HotStuff, Tendermint, and LibraBFT achieve progress with a linear message complexity and a constant time complexity once such round synchronization occurs. But round synchronization itself incurs an additional cost. By Dolev and Reischuk's lower bound, any deterministic solution must have $\Omega(n^2)$ communication complexity. Yet the question of randomized round synchronization with an expected linear message complexity remained open. 
We present an algorithm that, for the first time, achieves round synchronization with expected linear message complexity and expected constant latency. Existing protocols can use our round synchronization algorithm to solve Byzantine SMR with the same asymptotic performance.

