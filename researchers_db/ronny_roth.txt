Recent papers for Ronny Roth:

2023: Corrections to “Analog Error-Correcting Codes”
Abstract: In the above article <xref ref-type="bibr" rid="ref1">[1]</xref>, <xref ref-type="lemma" rid="lemma2">Lemma 2</xref> contained an error, which also affects the proof of Theorem 1 therein. Specifically, Theorem 1 holds only when <inline-formula> <tex-math notation="LaTeX">$\sigma = 0$ </tex-math></inline-formula> or when <inline-formula> <tex-math notation="LaTeX">$\tau = 0$ </tex-math></inline-formula>; otherwise, the “if” part in the theorem requires a stronger condition.

2023: On the Implementation of Boolean Functions on Content-Addressable Memories
Abstract: Let [q〉 denote the integer set {0, 1, …, q − 1} and let ${\mathbb{B}} = \left\{ {0,1} \right\}$. The problem of implementing functions $\left[ {\left. q \right\rangle } \right. \to {\mathbb{B}}$ on content-addressable memories (CAMs) is considered. CAMs can be classified by the input alphabet and the state alphabet of their cells; for example, in binary CAMs, those alphabets are both ${\mathbb{B}}$, while in a ternary CAM (TCAM), both alphabets are endowed with a "don’t care" symbol.This work is motivated by recent proposals for using CAMs for fast inference on decision trees. In such learning models, the tree nodes carry out integer comparisons, such as testing equality (x = t ?) or inequality (x ≤ t ?), where x ∈ [q〉 is an input to the node and t ∈ [q〉 is a node parameter. A CAM implementation of such comparisons includes mapping (i.e., encoding) t into internal states of some number n of cells and mapping x into inputs to these cells, with the goal of minimizing n.Such mappings are presented for various comparison families, as well as for the set of all functions $\left[ {\left. q \right\rangle } \right. \to {\mathbb{B}}$, under several scenarios of input and state alphabets of the CAM cells. All those mappings are shown to be optimal in that they attain the smallest possible n for any given q.

2022: Asymptotic Bounds on the Rate of Locally Repairable Codes
Abstract: New asymptotic upper bounds are presented on the rate of sequences of locally repairable codes (LRCs) with a prescribed relative minimum distance and locality over a finite field <inline-formula> <tex-math notation="LaTeX">$F$ </tex-math></inline-formula>. The bounds apply to LRCs in which the recovery functions are linear; in particular, the bounds apply to linear LRCs over <inline-formula> <tex-math notation="LaTeX">$F$ </tex-math></inline-formula>. The new bounds are shown to improve on previously published results, especially when the repair groups are disjoint, namely, they form a partition of the set of coordinates.

2022: Fault-Tolerant Neuromorphic Computing on Nanoscale Crossbar Architectures
Abstract: Recent coding techniques are reviewed for protecting nano-scale crossbar architectures against faults and computational errors. Two computational paradigms are considered: exact computation over the integers, and approximate computation over the reals.

2021: Higher-Order MDS Codes
Abstract: An improved Singleton-type upper bound is presented for the list decoding radius of linear codes, in terms of the code parameters <inline-formula> <tex-math notation="LaTeX">$[n,k,d]$ </tex-math></inline-formula> and the list size <inline-formula> <tex-math notation="LaTeX">$L$ </tex-math></inline-formula>. <inline-formula> <tex-math notation="LaTeX">$L$ </tex-math></inline-formula>-MDS codes are then defined as codes that attain this bound (under a slightly stronger notion of list decodability), with 1-MDS codes corresponding to ordinary linear MDS codes. Several properties of such codes are presented; in particular, it is shown that the 2-MDS property is preserved under duality. Finally, explicit constructions for 2-MDS codes are presented through generalized Reed–Solomon (GRS) codes.

2020: Analog error correcting codes for defect tolerant matrix multiplication in crossbars
Abstract: Despite great promises shown in the laboratory environment, memristor crossbar, or non-volatile resistive analog memory, based matrix multiplication accelerators suffer from unexpected computing errors, limiting opportunities to replace main-stream digital systems. While many previously demonstrated applications, such as neural networks, are tolerant of small errors, they are challenged by any significant outliers, which must be detected and corrected. Herein, we experimentally demonstrate an analog Error Correcting Code (ECC) scheme that considerably reduces the chance of substantial errors, by detecting and correcting errors with minimum hardware overhead. Different from well-known digital ECC in communication and memory, this analog version can tolerate small errors while detecting and correcting those over a predefined threshold. With this scheme, we can recover the MNIST handwritten digit classification accuracy experimentally from 90.31% to 96.21% in the event an array builds up shorted devices and from 73.12% to 97.36% when current noise is injected. For applications where high reliability and compute precision are demanded, such as in high-performance and scientific computing, we expect the schemes shown here to make analog computing more feasible.

2020: Variable-Length Constrained Coding and Kraft Conditions: The Parity-Preserving Case
Abstract: Previous work by the authors on parity-preserving fixed-length constrained encoders is extended to the variable-length case. Parity-preserving variable-length encoders are formally defined, and, to this end, Kraft conditions are developed for the parity-preserving variable-length setting. Then, a necessary and sufficient condition is presented for the existence of deterministic parity-preserving variable-length encoders for a given constraint. Examples are provided that show that there are coding ratios where parity-preserving variable-length encoders exist, while fixed-length encoders do not.

2020: On the Number of Factorizations of Polynomials over Finite Fields
Abstract: Motivated by coding applications, two enumeration problems are considered: the number of distinct divisors of a degree-m polynomial over $\mathbb{F} = GF(q)$, and the number of ways a polynomial can be written as a product of two polynomials of degree at most n over $\mathbb{F}$. For the two problems, bounds are obtained on the maximum number of factorizations, and a characterization is presented for polynomials attaining that maximum. Finally, expressions are presented for the average and the variance of the number of factorizations, for any given m (resp., n).

2020: Asymptotic Bounds on the Rate of Locally Repairable Codes
Abstract: New asymptotic upper bounds are presented on the rate of sequences of locally repairable codes (LRCs) with a prescribed relative minimum distance and locality over a finite field $F$. The bounds apply to LRCs in which the recovery functions are linear; in particular, the bounds apply to linear LRCs over $F$. The new bounds are shown to improve on previously published results, especially when the repair groups are disjoint.

2020: On Parity-Preserving Variable-Length Constrained Coding
Abstract: Previous work by the authors on parity-preserving fixed-length constrained encoders is extended to the variable-length case. Parity-preserving variable-length encoders are formally defined, and a necessary and sufficient condition is presented for the existence of deterministic parity-preserving variable-length encoders for a given constraint. Examples are provided that show that there are coding ratios where parity-preserving variable-length encoders exist, while fixed-length encoders do not.

2020: Analog Error-Correcting Codes
Abstract: Coding schemes are presented that provide the ability to locate computational errors above a prescribed threshold while using analog resistive devices for approximate real vector–matrix multiplication. In such devices, the matrix is programmed into the device by setting an array of resistors to have conductances proportional to the respective entries in the matrix. In the coding scheme that is considered in this work, redundancy columns are appended so that each row in the programmed matrix forms a codeword of a prescribed linear code <inline-formula> <tex-math notation="LaTeX">${\mathcal {C}}$ </tex-math></inline-formula> over the real field; the result of the multiplication of any input real row vector by the matrix is then also a codeword of <inline-formula> <tex-math notation="LaTeX">${\mathcal {C}}$ </tex-math></inline-formula>. While error values within <inline-formula> <tex-math notation="LaTeX">$\pm \delta $ </tex-math></inline-formula> in the entries of the result are tolerable (for some prescribed <inline-formula> <tex-math notation="LaTeX">$\delta > 0$ </tex-math></inline-formula>), outlying errors, with values outside the range <inline-formula> <tex-math notation="LaTeX">$\pm \Delta $ </tex-math></inline-formula> (for a prescribed <inline-formula> <tex-math notation="LaTeX">$\Delta \ge \delta $ </tex-math></inline-formula>) should be located and corrected. As a design and analysis tool for such a setting, a certain functional is defined for the code <inline-formula> <tex-math notation="LaTeX">${\mathcal {C}}$ </tex-math></inline-formula>, through which a characterization is obtained for the number of outlying errors that can be handled, as a function of the ratio <inline-formula> <tex-math notation="LaTeX">$\Delta /\delta $ </tex-math></inline-formula>. Several code constructions are then presented, primarily for the case of single outlying error handling. For this case, the coding problem is shown to be related to certain extremal problems on convex polygons.

2019: On the Pointwise Threshold Behavior of the Binary Erasure Polarization Subchannels
Abstract: It is shown that when Arıkan’s <inline-formula> <tex-math notation="LaTeX">$n$ </tex-math></inline-formula>-level polarization transformation is applied to the binary erasure channel, each of the resulting individual <inline-formula> <tex-math notation="LaTeX">$2^{n}$ </tex-math></inline-formula> subchannels has a sharp threshold, for sufficiently large <inline-formula> <tex-math notation="LaTeX">$n$ </tex-math></inline-formula>.

2019: Analog Error-Correcting Codes
Abstract: Coding schemes are presented that provide the ability to locate computational errors above a prescribed threshold while using analog devices for approximate real vector–matrix multiplication.

2019: The Capacity of Count-Constrained ICI-Free Systems
Abstract: A Markov chain approach is applied to determine the capacity of a general class of q-ary ICI-free constrained systems that satisfy an arbitrary count constraint.

2019: On Spectral Design Methods for Quasi-Cyclic Codes
Abstract: A method is provided for constructing upper triangular square matrices over the univariate polynomial ring over a finite field, under certain constraints on the eigenvalues of the matrices. In some cases of interest, the degree of the determinant of such matrices is shown to be the smallest possible. The method is then applied to construct generator polynomial matrices of quasi-cyclic codes for correcting phased burst errors. Finally, an interpolation-based list decoding algorithm is presented for these codes, which, for a wide range of code parameters, is shown to outperform existing list decoding schemes.

2019: Fault-Tolerant Dot-Product Engines
Abstract: Coding schemes are presented that provide the ability to correct and detect computational errors while using dot-product engines for integer vector–matrix multiplication. Both the <inline-formula> <tex-math notation="LaTeX">$L_{1}$ </tex-math></inline-formula>-metric and the Hamming metric are considered.

2019: On Bi-Modal Constrained Coding
Abstract: Bi-modal (respectively, multi-modal) constrained coding refers to an encoding model whereby a user input block can be mapped to two (respectively, multiple) codewords. In current storage applications, such as optical disks, multi-modal coding allows to achieve DC control, in addition to satisfying the runlength limited (RLL) constraint specified by the recording channel. In this work, a study is initiated on bi-modal fixed-length constrained encoders. Necessary and sufficient conditions are presented for the existence of such encoders for a given constraint. It is also shown that under somewhat stronger conditions, one can guarantee a bi-modal encoder with finite decoding delay.

2018: ENCODING FOR INPUT-CONSTRAINED CHANNELS RESEARCH THESIS SUBMITTED IN PARTIAL FULFILLMENT OF THE REQUIREMENTS FOR THE DEGREE OF MASTER OF SCIENCE IN COMPUTER SCIENCE
Abstract: Input-constrained channels are models for describing the read-write requirements of secondary storage systems, such as magnetic disks or optical devices. Examples for such requirements are the widely used (d; k)-run-length-limited (RLL) constraints, where each run of 0's between consecutive 1's in a binary sequence must have length at least d and at most k. A constrained system S is de ned as the set of constrained sequences obtained by reading the labels of paths of a nite labeled directed graph G. The graph G is then called the presentation of S. One goal in the study of constrained systems is designing encoders that map unconstrained sequences into constrained sequences of a given constrained system S. A xed rate p : q nite-state encoder for S encodes p-blocks of input bits to q-blocks in S, in a statedependent and lossless manner. The anticipation (or decoding look-ahead) of an encoder is the smallest integer A, if any, such that the encoder state at each time slot t, together with the q-blocks generated at times t; t+ 1; : : : ; t+ A, determine uniquely the p-block input at time slot t. One of the well known schemes for constructing nite-state encoders is the AdlerCoppersmith-Hassner algorithm, also known as the state-splitting algorithm. Any encoder obtained by the state-splitting algorithm from a deterministic presentation G has nite anticipation. In this work, we present lower bounds on the anticipation of encoders for given constrained systems, while strengthening the universality of the state-splitting algorithm. It is shown that if there exists an encoder with anticipation A for a given system, then an unreduced version of this encoder can be obtained by the state-splitting algorithm, using A rounds of splitting. Furthermore, by specifying several properties of those splittings, we obtain a lower bound on the anticipation of any encoder for a given constrained system. The new lower bound improves on previous known bounds and in particular, it is tight for several known and widely used systems, such as the (1,7)-RLL and the (2,7)-RLL constrained systems. 1 Techio n C om pu te r Sc ie nc e D ep ar tm en t M .S c. T he si s M SC -1 99 601 1 99 6 List of Symbols and Abbreviations RLL Run-Length-Limited V (G), E(G) Set of states and set of edges of a graph G S(G) Constrained system generated by a graph G GS Shannon cover of an irreducible constrained system S FG(v) Follower set of a state v in a graph G v u State v is dominated by state u (e), ( ) Initial state of an edge e or a path (e), ( ) Terminal state of an edge e or a path E Encoder graph TE( ; w) Set of all paths in the encoder graph E that begin with a path and continue with su xes that generate the word w GE Determinizing graph for an encoder E AG Adjacency matrix of a graph G (A) Perron eigenvalue of a square irreducible nonnegative matrix A x y (for vectors x = [ xu ]u and y = [ yu ]u of the same length) xu yu for every u. X (A; n) Set of all (A; n)-approximate eigenvectors for a given square nonnegative integer matrix A and a positive integer n C(S) Capacity of a constrained system S 2 T ec hn io n C om pu te r Sc ie nc e D ep ar tm en t M .S c. T he si s M SC -1 99 601 1 99 6 Chapter

2018: 236608-Coding and Algorithms for Memories Winter Semester 2018 / 2019 Linear Codes
Abstract: Let F be a field of size p, where p is a prime number. An (n,M, d) code C over a field F is called linear if for all c1, c2 ∈ C and a1, a2 ∈ F , it holds that a1c1 + a2c2 ∈ C. That is C is a linear sub-space of Fn over F . The dimension of a linear (n,M, d) code C over F is the dimension of C as a linear sub-space of Fn over F . Linear codes will be denoted by [n, k, d], where k denotes the dimension. The difference n− k is called the redundancy of the code and will be denoted by r.

2018: On decoding rank-metric codes over large fields
Abstract: A decoding algorithm is presented for rank-metric array codes that are based on diagonal interleaving of MDS codes. W.r.t. this metric, such array codes are known to be optimal when the underlying field is algebraically closed. It is also shown that for any list decoding radius that is smaller than the minimum rank distance, the list size can be bounded from above by an expression that is independent of the field.

