Recent papers for Ron Rothblum:

2024: Local Proofs Approaching the Witness Length
Abstract: Interactive oracle proofs (IOPs) are a hybrid between interactive proofs and PCPs. In an IOP, the prover is allowed to interact with a verifier (like in an interactive proof) by sending relatively long messages to the verifier, who in turn is only allowed to query a few of the bits that were sent (like in a PCP). Efficient IOPs are currently at the core of leading practical implementations of highly efficient proof-systems. In this work we construct, for a large class of NP relations, IOPs in which the communication complexity approaches the witness length. More precisely, for any NP relation for which membership can be decided in polynomial-time with bounded polynomial space (i.e., space nξ for some sufficiently small constant ξ > 0; e.g., SAT, Hamiltonicity, Clique, Vertex-Cover) and for any constant γ > 0, we construct an IOP with communication complexity (1 + γ) ⋅ n, where n is the original witness length. The number of rounds, as well as the number of queries made by the IOP verifier, are constant. This result improves over prior works on short IOPs/PCPs in two ways. First, the communication complexity in these short IOPs is proportional to the complexity of verifying the NP witness, which can be polynomially larger than the witness size. Second, even ignoring the difference between witness length and non-deterministic verification time, prior works incur (at the very least) a large constant multiplicative overhead to the communication complexity. In particular, as a special case, we also obtain an IOP for CircuitSAT with communication complexity (1 + γ) ⋅ t, for circuits of size t and any constant γ > 0. This improves upon the prior state-of-the-art work of Ben Sasson et al. (ICALP, 2017) who construct an IOP for CircuitSAT with communication length c ⋅ t for a large (unspecified) constant c ≥ 1. Our proof leverages the local testability and (relaxed) local correctability of high-rate tensor codes, as well as their support of a sumcheck-like procedure. In particular, we bypass the barrier imposed by the low rate of multiplication codes (e.g., Reed–Solomon, Reed–Muller, or AG codes)—a key building block of all known short PCP/IOP constructions.

2024: Batch Proofs Are Statistically Hiding
Abstract: Batch proofs are proof systems that convince a verifier that x1,…,xt ∈ L, for some NP language L, with communication that is much shorter than sending the t witnesses. In the case of statistical soundness (where the cheating prover is unbounded but the honest prover is efficient given the witnesses), interactive batch proofs are known for UP, the class of unique-witness NP languages. In the case of computational soundness (where both honest and dishonest provers are efficient), non-interactive solutions are now known for all of NP, assuming standard lattice or group assumptions. We exhibit the first negative results regarding the existence of batch proofs and arguments: - Statistically sound batch proofs for L imply that L has a statistically witness indistinguishable (SWI) proof, with inverse polynomial SWI error, and a non-uniform honest prover. The implication is unconditional for obtaining honest-verifier SWI or for obtaining full-fledged SWI from public-coin protocols, whereas for private-coin protocols full-fledged SWI is obtained assuming one-way functions. This poses a barrier for achieving batch proofs beyond UP (where witness indistinguishability is trivial). In particular, assuming that NP does not have SWI proofs, batch proofs for all of NP do not exist. - Computationally sound batch proofs (a.k.a batch arguments or BARGs) for NP, together with one-way functions, imply statistical zero-knowledge (SZK) arguments for NP with roughly the same number of rounds, an inverse polynomial zero-knowledge error, and non-uniform honest prover. Thus, constant-round interactive BARGs from one-way functions would yield constant-round SZK arguments from one-way functions. This would be surprising as SZK arguments are currently only known assuming constant-round statistically-hiding commitments. We further prove new positive implications of non-interactive batch arguments to non-interactive zero knowledge arguments (with explicit uniform prover and verifier): - Non-interactive BARGs for NP, together with one-way functions, imply non-interactive computational zero-knowledge arguments for NP. Assuming also dual-mode commitments, the zero knowledge can be made statistical. Both our negative and positive results stem from a new framework showing how to transform a batch protocol for a language L into an SWI protocol for L.

2024: Doubly-Efficient Batch Verification in Statistical Zero-Knowledge
Abstract: None

2024: Collision-Resistance from Multi-Collision-Resistance
Abstract: None

2024: Strong Batching for Non-Interactive Statistical Zero-Knowledge
Abstract: None

2023: Linear-Size Boolean Circuits for Multiselection
Abstract: We study the circuit complexity of the multiselection problem : given an input string x ∈ { 0 , 1 } n along with indices i 1 , . . . , i q ∈ [ n ], output ( x i 1 , . . . , x i q ). A trivial lower bound for the circuit size is the input length n + q · log( n ), but the straightforward construction has size Θ( q · n ). Our main result is an O ( n + q · log 3 ( n ))-size and O (log( n + q ))-depth circuit for multiselection. In particular, for any q ≤ n/ log 3 ( n ) the circuit has linear size and logarithmic depth. Prior to our work no linear-size circuit for multiselection was known for any q = ω (1) and regardless of depth.

2023: Efficient Interactive Proofs for Non-Deterministic Bounded Space
Abstract: The celebrated IP = PSPACE Theorem gives an efficient interactive proof for any bounded-space algorithm. In this work we study interactive proofs for non-deterministic bounded space computations. While Savitch’s Theorem shows that nondeterministic bounded-space algorithms can be simulated by deterministic bounded-space algorithms, this simulation has a quadratic overhead. We give interactive protocols for nondeterministic algorithms directly to get faster verifiers. More specifically, for any non-deterministic space S algorithm, we construct an interactive proof in which the verifier runs in time ˜ O ( n + S 2 ). This improves on the best previous bound of ˜ O ( n + S 3 ) and matches the result for deterministic space bounded algorithms, up to polylog( S ) factors. We further generalize to alternating bounded space algorithms. For any language L decided by a time T , space S algorithm that uses d alternations, we construct an interactive proof in which the verifier runs in time ˜ O ( n + S log( T ) + Sd ) and the prover runs in time 2 O ( S ) . For d = O (log( T )), this matches the best known interactive proofs for deterministic algorithms, up to polylog( S ) factors, and improves on the previous best verifier time for nondeterministic algorithms by a factor of log( T ). We also improve the best prior verifier time for unbounded alternations by a factor of S . Using known connections of bounded alternation algorithms to bounded depth circuits, we also obtain faster verifiers for bounded depth circuits with unbounded fan-in.

2023: Distribution-Free Proofs of Proximity
Abstract: Motivated by the fact that input distributions are often unknown in advance, distribution-free property testing considers a setting where the algorithmic task is to accept functions $f : [n] \to \{0,1\}$ with a certain property P and reject functions that are $\eta$-far from P, where the distance is measured according to an arbitrary and unknown input distribution $D \sim [n]$. As usual in property testing, the tester can only make a sublinear number of input queries, but as the distribution is unknown, we also allow a sublinear number of samples from the distribution D. In this work we initiate the study of distribution-free interactive proofs of proximity (df-IPPs) in which the distribution-free testing algorithm is assisted by an all powerful but untrusted prover. Our main result is that for any problem P $\in$ NC, any proximity parameter $\eta>0$, and any (trade-off) parameter $t\leq\sqrt{n}$, we construct a df-IPP for P with respect to $\eta$, that has query and sample complexities $t+O(1/\eta)$, and communication complexity $\tilde{O}(n/t + 1/\eta)$. For t as above and sufficiently large $\eta$ (namely, when $\eta>t/n$), this result matches the parameters of the best-known general purpose IPPs in the standard uniform setting. Moreover, for such t, its parameters are optimal up to poly-logarithmic factors under reasonable cryptographic assumptions for the same regime of $\eta$ as the uniform setting, i.e., when $\eta \geq 1/t$. For small $\eta$ (i.e., $\eta<t/n$), our protocol has communication complexity $\Omega(1/\eta)$, which is worse than the $\tilde{O}(n/t)$ communication complexity of the uniform IPPs (with the same query complexity). To improve on this gap, we show that for IPPs over specialised, but large distribution families, such as sufficiently smooth distributions and product distributions, the communication complexity reduces to $\tilde{O}(n/t^{1-o(1)})$.

2022: PPAD is as Hard as LWE and Iterated Squaring
Abstract: None

2022: Proving as fast as computing: succinct arguments with constant prover overhead
Abstract: Succinct arguments are proof systems that allow a powerful, but untrusted, prover to convince a weak verifier that an input x belongs to a language L ∈ NP, with communication that is much shorter than the NP witness. Such arguments, which grew out of the theory literature, are now drawing immense interest also in practice, where a key bottleneck that has arisen is the high computational cost of proving correctness. In this work we address this problem by constructing succinct arguments for general computations, expressed as Boolean circuits (of bounded fan-in), with a strictly linear size prover. The soundness error of the protocol is an arbitrarily small constant. Prior to this work, succinct arguments were known with a quasi-linear size prover for general Boolean circuits or with linear-size only for arithmetic circuits, defined over large finite fields. In more detail, for every Boolean circuit C=C(x,w), we construct an O(log|C|)-round argument-system in which the prover can be implemented by a size O(|C|) Boolean circuit (given as input both the instance x and the witness w), with arbitrarily small constant soundness error and using poly(λ,log|C|) communication, where λ denotes the security parameter. The verifier can be implemented by a size O(|x|) + poly(λ, log|C|) circuit following a size O(|C|) private pre-processing step, or, alternatively, by using a purely public-coin protocol (with no pre-processing) with a size O(|C|) verifier. The protocol can be made zero-knowledge using standard techniques (and with similar parameters). The soundness of our protocol is computational and relies on the existence of collision resistant hash functions that can be computed by linear-size circuits, such as those proposed by Applebaum et al. (ITCS, 2017). At the heart of our construction is a new information-theoretic interactive oracle proof (IOP), an interactive analog of a PCP, for circuit satisfiability, with constant prover overhead. The improved efficiency of our IOP is obtained by bypassing a barrier faced by prior IOP constructions, which needed to (either explicitly or implicitly) encode the entire computation using a multiplication code.

2022: Succinct Interactive Oracle Proofs: Applications and Limitations
Abstract: None

2022: Faster Sounder Succinct Arguments and IOPs
Abstract: . Succinct arguments allow a prover to convince a veriﬁer that a given statement is true, using an extremely short proof. A major bottleneck that has been the focus of a large body of work is in reducing the overhead incurred by the prover in order to prove correctness of the computation. By overhead we refer to the cost of proving correctness, divided by the cost of the original computation. In this work, for a large class of Boolean circuits C = C ( x, w ), we construct succinct arguments for the language { x : ∃ w C ( x, w ) = 1 } , with 2 − λ soundness error, and with prover overhead polylog( λ ). This result relies on the existence of (sub-exponentially secure) linear-size computable collision-resistant hash functions. The class of Boolean circuits that we can handle includes circuits with a repeated sub-structure, which arise in natural applications such as batch computation/veriﬁcation, hashing and related block chain applications. The succinct argument is obtained by constructing interactive oracle proofs for the same class of languages, with polylog( λ ) prover overhead, and soundness error 2 − λ . Prior to our work, the best IOP s for Boolean circuits either had prover overhead of polylog( | C | ) based on eﬃcient PCP s due to Ben Sasson et al. (STOC, 2013) or poly( λ ) due to Rothblum and Ron-Zewi (STOC, 2022).

2022: Delegation for Search Problems
Abstract: The theory of proof systems in general, and interactive proofs in particular, has been immensely influential. Such proof systems allow a prover to convince a verifier whether a given statement is true or not – namely to solve a decision problem. In this work we initiate a study of interactive proofs for search problems . More precisely, we consider a setting in which a client C , given an input x , would like to find a solution y satisfying ( x, y ) ∈ R , for a given relation R . The client wishes to delegate this work to an (untrusted) advisor A , who has more resources than C . We seek solutions in which the communication from A is short, and, in particular, shorter than the length of the output y . (In particular, this precludes the trivial solution of the advisor sending y and then proving that ( x, y ) ∈ R using a standard interactive proof.) We show that such search delegation schemes exist for several problems of interest including (1) longest common subsequence (LCS) and edit distance, (2) parsing context-free grammars and (3) k -SAT.

2022: Unstructured Hardness to Average-Case Randomness
Abstract: The leading technical approach in uniform hardness-to-randomness in the last two decades faced several well-known barriers that caused results to rely on overly strong hardness assumptions, and yet still yield suboptimal conclusions. In this work we show uniform hardness-to-randomness results that simultaneously break through all of the known barriers. Specifically, consider any one of the following three assumptions:1)For some $\epsilon>0$ there exists a function f computable by uniform circuits of size $2^{O(n)}$ and depth $2^{o(n)}$ such that f is hard for probabilistic time $2^{\epsilon n}$.2)For every $c\in \mathbb{N}$ there exists a function f computable by logspace-uniform circuits of polynomial size and depth n2 such that every probabilistic algorithm running in time nc fails to compute f on $\mathrm{a}(1/n)$-fraction of the inputs.3)For every $c\in \mathbb{N}$ there exists a logspace-uniform family of arithmetic formulas of degree n2 over a field of size poly $(n)$ such that no algorithm running in probabilistic time nc can evaluate the family on a worst-case input. Assuming any of these hypotheses, where the hardness is for every sufficiently large input length $n\in \mathbb{N}$, we deduce that $\mathcal{R}\mathcal{P}$ can be derandomized in polynomial time and on all input lengths, on average. Furthermore, under the first assumption we also show that $\mathcal{B}\mathcal{P}\mathcal{P}$ can be derandomized in polynomial time, on average and on all input lengths, with logarithmically many advice bits. On the way to these results we also resolve two related open problems. First, we obtain an optimal worst-case to average-case reduction for computing problems in linear space by uniform probabilistic algorithms; this result builds on a new instance checker based on the doubly efficient proof system of Goldwasser, Kalai, and Rothblum (J. ACM, 2015). Secondly, we resolve the main open problem in the work of Carmosino, Impagliazzo and Sabin (ICALP 2018), by deducing derandomization from weak and general fine-grained hardness hypotheses. The full version of this paper is available online [5].

2021: Fiat–Shamir via list-recoverable codes (or: parallel repetition of GMW is not zero-knowledge)
Abstract: In a seminal work, Goldreich, Micali and Wigderson (CRYPTO ’86) demonstrated the wide applicability of zero-knowledge proofs by constructing such a proof system for the NP-complete problem of graph 3-coloring. A long-standing open question has been whether parallel repetition of their protocol preserves zero knowledge. In this work, we answer this question in the negative, assuming a standard cryptographic assumption (i.e., the hardness of learning with errors (LWE)). Leveraging a connection observed by Dwork, Naor, Reingold, and Stockmeyer (FOCS ’99), our negative result is obtained by making positive progress on a related fundamental problem in cryptography: securely instantiating the Fiat-Shamir heuristic for eliminating interaction in public-coin interactive protocols. A recent line of work has shown how to instantiate the heuristic securely, albeit only for a limited class of protocols. Our main result shows how to instantiate Fiat-Shamir for parallel repetitions of much more general interactive proofs. In particular, we construct hash functions that, assuming LWE, securely realize the Fiat-Shamir transform for the following rich classes of protocols: 1) The parallel repetition of any “commit-and-open” protocol (such as the GMW protocol mentioned above), when a specific (natural) commitment scheme is used. Commit-and-open protocols are a ubiquitous paradigm for constructing general purpose public-coin zero knowledge proofs. 2) The parallel repetition of any base protocol that (1) satisfies a stronger notion of soundness called round-by-round soundness, and (2) has an efficient procedure, using a suitable trapdoor, for recognizing “bad verifier randomness” that would allow the prover to cheat. Our results are obtained by establishing a new connection between the Fiat-Shamir transform and list-recoverable codes. In contrast to the usual focus in coding theory, we focus on a parameter regime in which the input lists are extremely large, but the rate can be small. We give a (probabilistic) construction based on Parvaresh-Vardy codes (FOCS ’05) that suffices for our applications.

2021: Public-Coin Statistical Zero-Knowledge Batch Verification against Malicious Verifiers
Abstract: None

2021: Time- and Space-Efficient Arguments from Groups of Unknown Order
Abstract: None

2021: Toward Non-interactive Zero-Knowledge Proofs for NP from LWE
Abstract: None

2021: Small Circuits Imply Efficient Arthur-Merlin Protocols
Abstract: The inner product function ⟨ x, y ⟩ = P i x i y i mod 2 can be easily computed by a (linear-size) AC 0 ( ⊕ ) circuit: that is, a constant depth circuit with AND, OR and parity (XOR) gates. But what if we impose the restriction that the parity gates can only be on the bottom most layer (closest to the input)? Namely, can the inner product function be computed by an AC 0 circuit composed with a single layer of parity gates? This seemingly simple question is an important open question at the frontier of circuit lower bound research. In this work, we focus on a minimalistic version of the above question. Namely, whether the inner product function cannot be approximated by a small DNF augmented with a single layer of parity gates. Our main result shows that the existence of such a circuit would have unexpected implications for interactive proofs, or more specifically, for interactive variants of the Data Streaming and Communication Complexity models. In particular, we show that the existence of such a small (i.e., polynomial-size) circuit yields:

2021: PCPs and Instance Compression from a Cryptographic Lens
Abstract: ,

