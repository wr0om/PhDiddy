Recent papers for Moses Yoram:

2024: The Observer Effect in Computer Networks
Abstract: Network measurement involves an inherent tradeoff between accuracy and overhead; higher accuracy typically comes at the expense of greater measurement overhead (measurement frequency, number of probe packets, etc.). Capturing the"right"balance between these two desiderata - high accuracy and low overhead - is a key challenge. However, the manner in which accuracy and overhead are traded off is specific to the measurement method, rendering apples-to-apples comparisons difficult. To address this, we put forth a novel analytical framework for quantifying the accuracy-overhead tradeoff for network measurements. Our framework, inspired by the observer effect in modern physics, introduces the notion of a network observer factor, which formally captures the relation between measurement accuracy and overhead. Using our"network observer framework", measurement methods for the same task can be characterized in terms of their network observer factors, allowing for apples-to-apples comparisons. We illustrate the usefulness of our approach by showing how it can be applied to various application domains and validate its conclusions through experimental evaluation.

2023: Timed Signalling Processes
Abstract: Circuits often use knowledge of time to order actions in a computation. The commonly used bundling constraint in bundled-data circuits states that a request signal must arrive only after the corresponding data wires have the correct value. Various informal and formal mechanisms have been used by designers to capture sufficient conditions for such constraints to be satisfied, including relative timing, pulse width requirements, and regions where signal changes are prohibited. We study the problem of ordering signal transitions in an asynchronous computation when there is knowledge of wire delay and computation delay, but where time is not avaiable directly as a variable to any participating process. In this context, we introduce two signalling patterns: a timing fork, and a novel structure we call a zigzag pattern. We show that a zigzag pattern is sufficient to order signal transitions in the timed asynchronous setting. More importantly we show that if two signal transitions are ordered, then there exists a generalized zigzag pattern that guarantees their ordering. This shows that a zigzag pattern is the fundamental construct needed to order signal transitions in the timed asynchronous circuit context. We show how such patterns capture commonly used timing constraints in practical asynchronous circuits.

2023: Opportunistic Mutual Exclusion
Abstract: Mutual exclusion is an important problem in the context of shared resource usage, where only one process can be using the shared resource at any given time. A mutual exclusion protocol that does not use information on the duration for which each process uses the resource can lead to sub-optimal utilization times. We consider a simple two-process mutual exclusion problem with a central server that provides access to the shared resource. We show that even in the absence of a clock, under certain conditions, the server can opportunistically grant early access to a client based on timing information. We call our new protocol opportunistic mutual exclusion. Our approach requires an extra request signal on each channel between client and server to convey extra information, and the server can grant early access based only on the order of events rather than through measuring time. We derive the handshaking specification and production rules for our protocol, and report on the energy and delay of the circuits in a 65nm process.

2022: Null Messages, Information and Coordination: Preliminary version
Abstract: This paper investigates the transfer of information in fault-prone synchronous systems using null messages. The notion of an f -resilient message block is deﬁned to capture the fundamental communication pattern for knowledge transfer. This pattern may involve null messages in addition to explicit messages, and hence, it provides a fault-tolerant extension of the classic notion of a message-chain. Based on the above, we provide tight necessary and suﬃcient characterizations of the generalized communication patterns, including actual messages and null messages, that can serve to solve the distributed tasks of (nice-run) Signalling and Ordered Response

2022: Null Messages, Information and Coordination
Abstract: This paper investigates the role that null messages play in synchronous systems with and without failures, and provides necessary and sufficient conditions on the structure of protocols for information transfer and coordination there. We start by introducing a new and more refined definition of null messages. A generalization of message chains that allow these null messages is provided, and is shown to be necessary and sufficient for information transfer in reliable systems. Coping with crash failures requires a much richer structure, since not receiving a message may be the result of the sender's failure. We introduce a class of communication patterns called {\em resilient message blocks}, which impose a stricter condition on protocols than the {\em silent choirs} of Goren and Moses (2020). Such blocks are shown to be necessary for information transfer in crash-prone systems. Moreover, they are sufficient in several cases of interest, in which silent choirs are not. Finally, a particular combination of resilient message blocks is shown to be necessary and sufficient for solving the Ordered Response coordination problem.

2022: Information Flow Guided Synthesis
Abstract: None

2022: Brief Announcement: Null Messages, Information and Coordination
Abstract: This paper investigates how null messages can transfer information in fault-prone synchronous systems. The notion of an f -resilient message block is defined and is shown to capture the fundamental communication pattern for knowledge transfer. In general, this pattern combines both null messages and explicit messages. It thus provides a fault-tolerant extension of the classic notion of a message-chain. Based on the above, we provide tight necessary and sufficient characterizations of the generalized communication patterns that can serve to solve the distributed tasks of (nice-run) Signalling and Ordered Response.

2021: Optimistically tuning synchronous byzantine consensus: another win for null messages
Abstract: None

2021: Stochastic coordination in heterogeneous load balancing systems
Abstract: None

2020: Silence
Abstract: The cost of communication is a substantial factor affecting the scalability of many distributed applications. Every message sent can incur a cost in storage, computation, energy, and bandwidth. Consequently, reducing the communication costs of distributed applications is highly desirable. The best way to reduce message costs is by communicating without sending any messages whatsoever. This article initiates a rigorous investigation into the use of silence in synchronous settings, in which processes can fail. We formalize sufficient conditions for information transfer using silence, as well as necessary conditions for particular cases of interest. This allows us to identify message patterns that enable communication through silence. In particular, a pattern called a silent choir is identified, and shown to be central to information transfer via silence in failure-prone systems. The power of the new framework is demonstrated on the atomic commitment problem (AC). A complete characterization of the tradeoff between message complexity and round complexity in the synchronous model with crash failures is provided, in terms of lower bounds and matching protocols. In particular, a new message-optimal AC protocol is designed using silence, in which processes decide in three rounds in the common case. This significantly improves on the best previously known message-optimal AC protocol, in which decisions were performed in Θ(n) rounds. And in the naked light I saw Ten thousand people, maybe more People talking without speaking … People writing songs that voices never share And no one dared Disturb the sound of silence Paul Simon, 1964

2020: Probabilistic Indistinguishability and the Quality of Validity in Byzantine Agreement
Abstract: This paper provides a formal framework for reasoning about randomized distributed algorithms. We generalize the notion of indistinguishability, the most useful tool in deterministic lower bounds, to apply to a probabilistic setting. We use the new notion to prove a lower bound on the probability at which it can be guaranteed that honest parties will not decide on a possibly bogus value. Moreover, we show that the bound is tight by providing a protocol that matches the bound. This completely characterizes the quality of decisions that protocols for a randomized multi-valued Consensus problem can guarantee in an asynchronous environment with Byzantine faults. Proving lower bounds for probabilistic protocols can be rather subtle. Probabilistic protocols have been around for at least four decades and are receiving a lot of attention with the emergence of blockchain systems. Nonetheless, we are aware of only a handful of randomized lower bounds. The formal tool that we develop in order to carry out our lower bound proof is of independent interest. It provides a rigorous yet accessible means to prove lower bounds for probabilistic protocols in general.

2020: Brief Announcement: On Using Null Messages in a Byzantine Setting
Abstract: In reliable settings, null messages allow the transfer of information without explicit communication in cases of interest. We investigate the use of null messages in the much more challenging Byzantine model (without signatures). Different ways of using null messages are discussed. One of them, called a silent validation round, can provide processes with global information about all correct sites of the system, without any message exchange. As a case study, we consider optimizing the behavior in failure-free runs of protocols for the classic Byzantine Consensus problem.

2020: Distributed Dispatching in the Parallel Server Model
Abstract: With the rapid increase in the size and volume of cloud services and data centers, architectures with multiple job dispatchers are quickly becoming the norm. Load balancing is a key element of such systems. Nevertheless, current solutions to load balancing in such systems admit a paradoxical behavior in which more accurate information regarding server queue lengths degrades performance due to herding and detrimental incast effects. Indeed, both in theory and in practice, there is a common doubt regarding the value of information in the context of multi-dispatcher load balancing. As a result, both researchers and system designers resort to more straightforward solutions, such as the power-of-two-choices to avoid worst-case scenarios, potentially sacrificing overall resource utilization and system performance. A principal focus of our investigation concerns the value of information about queue lengths in the multi-dispatcher setting. We argue that, at its core, load balancing with multiple dispatchers is a distributed computing task. In that light, we propose a new job dispatching approach, called Tidal Water Filling, which addresses the distributed nature of the system. Specifically, by incorporating the existence of other dispatchers into the decision-making process, our protocols outperform previous solutions in many scenarios. In particular, when the dispatchers have complete and accurate information regarding the server queues, our policies significantly outperform all existing solutions.

2020: Probably Approximately Knowing
Abstract: Whereas deterministic protocols are typically guaranteed to obtain particular goals of interest, probabilistic protocols typically provide only probabilistic guarantees. This paper initiates an investigation of the interdependence between actions and subjective beliefs of agents in a probabilistic setting. In particular, we study what probabilistic beliefs an agent should have when performing actions, in a protocol that satisfies a probabilistic constraint of the form: Condition φ should hold with probability at least p when action α is performed. Our main result is that the expected degree of an agent's belief in φ when it performs α equals the probability that φ holds when α is performed. Indeed, if the threshold of the probabilistic constraint should hold with probability p = 1 − ε2 for some small value of ε then, with probability 1 − ε, when the agent acts it will assign a probabilistic belief no smaller than 1 − ε to the possibility that φ holds. In other words, viewing strong belief as, intuitively, approximate knowledge, the agent must Probably Approximately Know (PAK-know) that φ is true when it acts.

2019: Byzantine Consensus in the Common Case
Abstract: Modular methods to transform Byzantine consensus protocols into ones that are fast and communication efficient in the common cases are presented. Small and short protocol segments called layers are custom designed to optimize performance in the common case. When composed with a Byzantine consensus protocol of choice, they allow considerable control over the tradeoff in the combined protocol's behavior in the presence of failures and its performance in their absence. When runs are failure free in the common case, the resulting protocols decide in two rounds and require $2nt$ bits of communication. For the common case assumption that all processors propose 1 and no failures occur, we show a transformation in which decisions are made in one round, and no bits of communication are exchanged. The resulting protocols achieve better common-case complexity than all existing Byzantine consensus protocols. Finally, in the rare instances in which the common case does not occur, a small cost is added to the complexity of the original consensus protocol being transformed. The key ingredient of these layers that allows both time and communication efficiency in the common case is the use of {\it silent confirmation rounds}, which are rounds where considerable relevant information can be obtained in the absence of any communication whatsoever.

2019: Asynchronous Signalling Processes
Abstract: A model of processes that interact via asynchronous wires carrying Boolean signals is presented. In this model, modules, called processes, can be made arbitrarily complex, can maintain local memory and can have an arbitrary number of inputs and outputs. A variety of circuit models can be represented by networks of signalling processes. It is shown that in a network of signalling processes consisting solely of single-ouput processes and forks, every module is an eventual C element. Consequently, the computational power of such a network is severely limited. This establishes that the celebrated C-element property of DI circuits follows solely from the fact that single output modules communicate over stable asynchronous wires. Conversely, it is shown that any Boolean function can be implemented using four input/two-output processes where every process is either one gate (single output) or a pair of gates (two output).

2019: Timing in Software-Defined and Centrally-Managed Networks
Abstract: The work described in this paper explores the use of time and synchronized clocks in centrally-managed and Software Defined Networks (SDNs). One of the main goals of this work is to analyze use cases in which explicit use of time is beneficial. Both theoretical and practical aspects of timed coordination and synchronized clocks in centralized environments are analyzed. Some of the products of this work are already incorporated in the OpenFlow specification, and open source prototypes of the main components are publicly available.

2019: A Characterization of Consensus Solvability for Closed Message Adversaries
Abstract: Distributed computations in a synchronous system prone to message loss can be modeled as a game between a (deterministic) distributed algorithm versus an omniscient message adversary. The latter determines, for each round, the directed communication graph that speciﬁes which messages can reach their destination. Message adversary deﬁnitions range from oblivious ones, which pick the communication graphs arbitrarily from a given set of candidate graphs, to general message adversaries, which are speciﬁed by the set of sequences of communication graphs (called admissible communication patterns) that they may generate. This paper provides a complete characterization of consensus solvability for closed message adversaries, where every inadmissible communication pattern has a ﬁnite preﬁx that makes all (inﬁnite) extensions of this preﬁx inadmissible. Whereas every oblivious message adversary is closed, there are also closed message adversaries that are not oblivious. We provide a tight non-topological, purely combinatorial characterization theorem, which reduces consensus solvability to a simple condition on preﬁxes of the communication patterns. Our result not only non-trivially generalizes the known combinatorial characterization of the consensus solvability for oblivious message adversaries by Coulouma, Godard, and Peters (Theor. Comput. Sci., 2015), but also provides the ﬁrst combinatorial characterization for this important class of message adversaries that is formulated directly on the preﬁxes of the communication patterns.

2018: Introduction to the special issue of papers from DISC 2015
Abstract: None

2018: 1 The Ricart And Agrawala Algorithm The RA Algorithm
Abstract: The summer research under Prof Yoram was focussed on studying different solutions to the Mutual Exclusion Problem, trying to prove them correct and if possible come up with an optimized version. This report tries to prove the Ricart Agrawala solution to ME problem and suggest possible optimized versions of algorithm. The proof is very much along the lines of the proof given for the Bakery algorithm in the Boulangerie paper [1]. 1 The Ricart And Agrawala Algorithm The RA Algorithm [2] as it is called in short is one of the classic solutions to the Mutual Exclusion Problem in a network topographay. The algorithm is inspired by the very famous Lamport’s Bakery algorithm [3] for Mutual Exclusion in a shared memory scenerio. The setting of the algorithm is a computer network where nodes can communicate only by messages and do not share memory. Intuitively the algorithm uses the permission based approach to find out for each node if it has priority over all the processes. If the node gets permission from all other nodes, it can enter critical section. The algorithm is symmetrical across nodes and each node has three processes to implement the mutual exclusion: 1. One is awakened when mutual exclusion is invoked on behalf of this node. 2. Another receives and processes REQUEST messages. 3. The last receives and processes REPLY messages. The three processes run asynchronously but operate on a set of common variables. A semaphore is used to serialize access to the common variables when necessary. If a node can generate multiple internal requests for mutual exclusion, it must have a method for serializing those requests.

