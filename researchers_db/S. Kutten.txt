2024: The Impact of Asynchrony on Stability of MAC
Abstract: A large volume of work has already studied various aspects of a synchronous multiple access channel (MAC). However, synchronization is costly and far from reality. Very little is known in the case when stations communicating on the channel may observe asynchronous behavior. Unfortunately, in certain strong asynchrony settings it is impossible to ensure even a small positive throughput (deterministically). Hence, in this paper, we study whether a limited amount of synchrony is already enough for obtaining stability and high throughput. More specifically, we present a novel model to capture a bounded asynchrony, where the “bounded” aspect is captured by an upper bound $R$ on the length of any asynchronous time slot. We design two distributed deterministic algorithms to schedule transmissions of dynamically arriving packets at asynchronous stations, which guarantee optimal throughput for all but one packet injection rates and bounded queues at any time (this combination is sometimes known as optimal stable throughput). One of these algorithms is collision-free, while the other, instead, avoids control messages. Combining these results with our impossibility results we characterize exactly the very limited case where there is an inherent difference between synchronous and asynchronous networks for obtaining optimal stable throughput for this problem. As a subroutine, we design a new leader election algorithm for this model and prove upper and lower bounds on the number of slots. Interestingly, when $R$ is a constant, our results match (asymptotically) the known results in synchronous slotted networks, while if $R$ is a larger parameter, our lower bound proves that an additional factor of $\Omega(\frac{R}{\log R})$ is necessary in the formula on the number of slots.

2024: Tight Bounds on the Message Complexity of Distributed Tree Verification
Abstract: We consider the message complexity of verifying whether a given subgraph of the communication network forms a tree with specific properties both in the KT-$\rho$ (nodes know their $\rho$-hop neighborhood, including node IDs) and the KT-$0$ (nodes do not have this knowledge) models. We develop a rather general framework that helps in establishing tight lower bounds for various tree verification problems. We also consider two different verification requirements: namely that every node detects in the case the input is incorrect, as well as the requirement that at least one node detects. The results are stronger than previous ones in the sense that we assume that each node knows the number $n$ of nodes in the graph (in some cases) or an $\alpha$ approximation of $n$ (in other cases). For spanning tree verification, we show that the message complexity inherently depends on the quality of the given approximation of $n$: We show a tight lower bound of $\Omega(n^2)$ for the case $\alpha \ge \sqrt{2}$ and a much better upper bound (i.e., $O(n \log n)$) when nodes are given a tighter approximation. On the other hand, our framework also yields an $\Omega(n^2)$ lower bound on the message complexity of verifying a minimum spanning tree (MST), which reveals a polynomial separation between ST verification and MST verification. This result holds for randomized algorithms with perfect knowledge of the network size, and even when just one node detects illegal inputs, thus improving over the work of Kor, Korman, and Peleg (2013). For verifying a $d$-approximate BFS tree, we show that the same lower bound holds even if nodes know $n$ exactly, however, the lower bound is sensitive to $d$, which is the stretch parameter.

2023: Improved Tradeoffs for Leader Election
Abstract: We consider leader election in clique networks, where n nodes are connected by point-to-point communication links. For the synchronous clique under simultaneous wake-up, i.e., where all nodes start executing the algorithm in round 1, we show a tradeoff between the number of messages and the amount of time. The previous lower bound side of such a tradeoff, in the seminal paper of Afek and Gafni (1991), was shown only assuming adversarial wake-up. Interestingly, our new tradeoff also improves the previous lower bounds for a large part of the spectrum, even under simultaneous wake-up. More specifically, we show that any deterministic algorithm with a message complexity of n f(n) requires Ω((log n) / (log f(n)+1)) rounds, for f(n) > 1. Our result holds even if the node IDs are chosen from a relatively small set of size Θ(n log n), as we are able to avoid using Ramsey's theorem, in contrast to many existing lower bounds for deterministic algorithms. We also give an upper bound that improves over the previously-best tradeoff achieved by the algorithm of Afek and Gafni. Our second contribution for the synchronous clique under simultaneous wake-up is to show that Ω (n log n) is in fact a lower bound on the message complexity that holds for any deterministic algorithm with a termination time T(n) (i.e., any function of n), for a sufficiently large ID space. We complement this result by giving a simple deterministic algorithm that achieves leader election in sublinear time while sending only o(n log n) messages, if the ID space is of at most linear size. We also show that Las Vegas algorithms (that never fail) require Θ(n) messages. This exhibits a gap between Las Vegas and Monte Carlo algorithms. For the synchronous clique under adversarial wake-up, we show that Ω(n3/2) is a lower bound for 2-round algorithms. Our result is the first superlinear lower bound for randomized leader election algorithms in the clique. We also give a simple algorithm that matches this bound. Finally, we turn our attention to the asynchronous clique: Assuming adversarial wake-up, we give a randomized algorithm that, for any k ∈ [2, O(log n/log log n)], achieves a message complexity of O(n1+1/k) and an asynchronous time complexity of k + 8. Our algorithm achieves the first tradeoff between messages and time in the asynchronous model. For simultaneous wake-up, we translate the deterministic tradeoff algorithm of Afek and Gafni to the asynchronous model, thus partially answering an open problem they pose.

2023: Improved Tradeo ff s for Leader Election
Abstract: We consider leader election in clique networks, where 𝑛 nodes are connected by point-to-point communication links. For the synchronous clique under simultaneous wake-up , i.e., where all nodes start executing the algorithm in round 1, we show a tradeo ff between the number of messages and the amount of time. The previous lower bound side of such a tradeo ff , in the seminal paper of Afek and Gafni (1991), was shown only assuming adversarial wake-up. Interestingly, our new tradeo ff also improves the previous lower bounds for a large part of the spectrum, even under simultaneous wake-up. More speci fi cally, we show that any deterministic algorithm with a message complexity of 𝑛 𝑓 ( 𝑛 ) requires Ω

2022: Locally Restricted Proof Labeling Schemes (Full Version)
Abstract: Introduced by Korman, Kutten, and Peleg (PODC 2005), a proof labeling scheme (PLS) is a distributed verification system dedicated to evaluating if a given configured graph satisfies a certain property. It involves a centralized prover, whose role is to provide proof that a given configured graph is a yes-instance by means of assigning labels to the nodes, and a distributed verifier, whose role is to verify the validity of the given proof via local access to the assigned labels. In this paper, we introduce the notion of a locally restricted PLS in which the prover's power is restricted to that of a LOCAL algorithm with a polylogarithmic number of rounds. To circumvent inherent impossibilities of PLSs in the locally restricted setting, we turn to models that relax the correctness requirements by allowing the verifier to accept some no-instances as long as they are not"too far"from satisfying the property in question. To this end, we evaluate (1) distributed graph optimization problems (OptDGPs) based on the notion of an approximate proof labeling scheme (APLS) (analogous to the type of relaxation used in sequential approximation algorithms); and (2) configured graph families (CGFs) based on the notion of atesting proof labeling schemes (TPLS) (analogous to the type of relaxation used in property testing algorithms).

2022: An Almost Singularly Optimal Asynchronous Distributed MST Algorithm
Abstract: A singularly (near) optimal distributed algorithm is one that is (near) optimal in \emph{two} criteria, namely, its time and message complexities. For \emph{synchronous} CONGEST networks, such algorithms are known for fundamental distributed computing problems such as leader election [Kutten et al., JACM 2015] and Minimum Spanning Tree (MST) construction [Pandurangan et al., STOC 2017, Elkin, PODC 2017]. However, it is open whether a singularly (near) optimal bound can be obtained for the MST construction problem in general \emph{asynchronous} CONGEST networks. We present a randomized distributed MST algorithm that, with high probability, computes an MST in \emph{asynchronous} CONGEST networks and takes $\tilde{O}(D^{1+\epsilon} + \sqrt{n})$ time and $\tilde{O}(m)$ messages, where $n$ is the number of nodes, $m$ the number of edges, $D$ is the diameter of the network, and $\epsilon>0$ is an arbitrarily small constant (both time and message bounds hold with high probability). Our algorithm is message optimal (up to a polylog$(n)$ factor) and almost time optimal (except for a $D^{\epsilon}$ factor). Our result answers an open question raised in Mashregi and King [DISC 2019] by giving the first known asynchronous MST algorithm that has sublinear time (for all $D = O(n^{1-\epsilon})$) and uses $\tilde{O}(m)$ messages. Using a result of Mashregi and King [DISC 2019], this also yields the first asynchronous MST algorithm that is sublinear in both time and messages in the $KT_1$ CONGEST model. A key tool in our algorithm is the construction of a low diameter rooted spanning tree in asynchronous CONGEST that has depth $\tilde{O}(D^{1+\epsilon})$ (for an arbitrarily small constant $\epsilon>0$) in $\tilde{O}(D^{1+\epsilon})$ time and $\tilde{O}(m)$ messages. To the best of our knowledge, this is the first such construction that is almost singularly optimal in the asynchronous setting.

2021: Multicast Communications with Varying Bandwidth Constraints
Abstract: To find a maximum number of communication requests that can be satisfied concurrently, is a fundamental network scheduling problem. In this work we investigate the problem of finding a maximum number of multicast requests that can be scheduled simultaneously in a tree network in which the edges and links have heterogeneous bandwidth limitations.This problem generalizes two problems studied in the literature: maximum k-colorable subgraph in chordal graphs, maximum multi-commodity flow in trees. The problem is NP-hard and admits a 1.585-approximation in the special case of homogeneous bandwidth limitations.We first show that the problem is harder to approximate when the bandwidth limitations are heterogeneous, i.e. vary from link to link and from node to node. We then generalize of a classical algorithm and obtain an M-approximation where M is the maximum number of leaves of the communication subtrees. Surprisingly, variants of the same algorithm, are used in the literature at least four times to solve related problems. There exists a polynomial-time algorithm for the special case of unicast requests and star topology. We generalize this result and relax the second requirement so that the set of unicast requests share a common vertex with no restriction on the tree topology.

2021: Efficient Deterministic Leader Election for Programmable Matter
Abstract: It was suggested that a programmable matter system (composed of multiple computationally weak mobile particles) should remain connected at all times since otherwise, reconnection is difficult and may be impossible. At the same time, it was not clear that allowing the system to disconnect carried a significant advantage in terms of time complexity. We demonstrate for a fundamental task, that of leader election, an algorithm where the system disconnects and then reconnects automatically in a non-trivial way (particles can move far away from their former neighbors and later reconnect to others). Moreover, the runtime of the temporarily disconnecting deterministic leader election algorithm is linear in the diameter. Hence, the disconnecting -- reconnecting algorithm is as fast as previous randomized algorithms. When comparing to previous deterministic algorithms, we note that some of the previous work assumed weaker schedulers. Still, the runtime of all the previous deterministic algorithms that did not assume special shapes of the particle system (shapes with no holes) was at least quadratic in n, where n is the number of particles in the system. (Moreover, the new algorithm is even faster in some parameters than the deterministic algorithms that did assume special initial shapes.) Since leader election is an important module in algorithms for various other tasks, the presented algorithm can be useful for speeding up other algorithms under the assumption of a strong scheduler. This leaves open the question: "can a deterministic algorithm be as fast as the randomized ones also under weaker schedulers?''

2021: Singularly Near Optimal Leader Election in Asynchronous Networks
Abstract: This paper concerns designing distributed algorithms that are {\em singularly optimal}, i.e., algorithms that are {\em simultaneously} time and message {\em optimal}, for the fundamental leader election problem in {\em asynchronous} networks. Kutten et al. (JACM 2015) presented a singularly near optimal randomized leader election algorithm for general {\em synchronous} networks that ran in $O(D)$ time and used $O(m \log n)$ messages (where $D$, $m$, and $n$ are the network's diameter, number of edges and number of nodes, respectively) with high probability.\footnote{Throughout,"with high probability"means"with probability at least $1-1/n^c$, for constant $c$."} Both bounds are near optimal (up to a logarithmic factor), since $\Omega(D)$ and $\Omega(m)$ are the respective lower bounds for time and messages for leader election even for synchronous networks and even for (Monte-Carlo) randomized algorithms. On the other hand, for general asynchronous networks, leader election algorithms are only known that are either time or message optimal, but not both. Kutten et al. (DISC 2020) presented a randomized asynchronous leader election algorithm that is singularly near optimal for \emph{complete networks}, but left open the problem for general networks. This paper shows that singularly near optimal (up to polylogarithmic factors) bounds can be achieved for general {\em asynchronous} networks. We present a randomized singularly near optimal leader election algorithm that runs in $O(D + \log^2n)$ time and $O(m\log^2 n)$ messages with high probability. Our result is the first known distributed leader election algorithm for asynchronous networks that is near optimal with respect to both time and message complexity and improves over a long line of results including the classical results of Gallager et al. (ACM TOPLAS, 1983), Peleg (JPDC, 1989), and Awerbuch (STOC 89).

2021: Fully Adaptive Self-Stabilizing Transformer for LCL Problems
Abstract: The first generic self-stabilizing transformer for local problems in a constrained bandwidth model is introduced. This transformer can be applied to a wide class of locally checkable labeling (LCL) problems, converting a given fault free synchronous algorithm that satisfies certain conditions into a self-stabilizing synchronous algorithm for the same problem. The resulting self-stabilizing algorithms are anonymous, size-uniform, and \emph{fully adaptive} in the sense that their time complexity is bounded as a function of the number $k$ of nodes that suffered faults (possibly at different times) since the last legal configuration. Specifically, for graphs whose degrees are up-bounded by $\Delta$, the algorithms produced by the transformer stabilize in time proportional to $\log (k + \Delta)$ in expectation, independently of the number of nodes in the graph. As such, the transformer is applicable also for infinite graphs (with degree bound $\Delta$). Another appealing feature of the transformer is its small message size overhead. The transformer is applied to known algorithms (or simple variants thereof) for some classic LCL problems, producing the first anonymous size-uniform self-stabilizing algorithms for these problems that are provably fully adaptive. From a technical point of view, the transformer's key design feature is a novel probabilistic tool that allows different nodes to act in synchrony even though their clocks may have been adversarially manipulated.

2020: Online Paging with a Vanishing Regret
Abstract: This paper considers a variant of the online paging problem, where the online algorithm has access to multiple predictors, each producing a sequence of predictions for the page arrival times. The predictors may have occasional prediction errors and it is assumed that at least one of them makes a sublinear number of prediction errors in total. Our main result states that this assumption suffices for the design of a randomized online algorithm whose time-average regret with respect to the optimal offline algorithm tends to zero as the time tends to infinity. This holds (with different regret bounds) for both the full information access model, where in each round, the online algorithm gets the predictions of all predictors, and the bandit access model, where in each round, the online algorithm queries a single predictor. 
While online algorithms that exploit inaccurate predictions have been a topic of growing interest in the last few years, to the best of our knowledge, this is the first paper that studies this topic in the context of multiple predictors. Moreover, to the best of our knowledge, this is also the first paper that aims for (and achieves) online algorithms with a vanishing regret for a classic online problem under reasonable assumptions.

2020: Efficient Self-Stabilizing Leader Election ( Full Version ) ∗
Abstract: This paper presents a randomized self-stabilizing algorithm that elects a leader r in a general n-node undirected graph and constructs a spanning tree T rooted at r. The algorithm works under the synchronous message passing network model, assuming that the nodes know a linear upper bound on n and that each edge has a unique ID known to both its endpoints (or, alternatively, assuming the KT1 model). The highlight of this algorithm is its superior communication efficiency: It is guaranteed to send a total of Õ(n) messages, each of constant size, till stabilization, while stabilizing in Õ(n) rounds, in expectation and with high probability. After stabilization, the algorithm sends at most one constant size message per round while communicating only over the (n− 1) edges of T . In all these aspects, the communication overhead of the new algorithm is far smaller than that of the existing (mostly deterministic) self-stabilizing leader election algorithms. The algorithm is relatively simple and relies mostly on known modules that are common in the fault free leader election literature; these modules are enhanced in various subtle ways in order to assemble them into a communication efficient self-stabilizing algorithm.

2020: Singularly Optimal Randomized Leader Election
Abstract: This paper concerns designing distributed algorithms that are singularly optimal, i.e., algorithms that are simultaneously time and message optimal, for the fundamental leader election problem in networks. Our main result is a randomized distributed leader election algorithm for asynchronous complete networks that is essentially (up to a polylogarithmic factor) singularly optimal. Our algorithm uses $O(n)$ messages with high probability and runs in $O(\log^2 n)$ time (with high probability) to elect a unique leader. The $O(n)$ message complexity should be contrasted with the $\Omega(n \log n)$ lower bounds for the deterministic message complexity of leader election algorithms (regardless of time), proven by Korach, Moran, and Zaks (TCS, 1989) for asynchronous algorithms and by Afek and Gafni (SIAM J. Comput., 1991) for synchronous networks. Hence, our result also separates the message complexities of randomized and deterministic leader election. More importantly, our (randomized) time complexity of $O(\log^2 n)$ for obtaining the optimal $O(n)$ message complexity is significantly smaller than the long-standing $\tilde{\Theta}(n)$ time complexity obtained by Afek and Gafni and by Singh (SIAM J. Comput., 1997) for message optimal (deterministic) election in asynchronous networks. 
In synchronous complete networks, Afek and Gafni showed an essentially singularly optimal deterministic algorithm with $O(\log n)$ time and $O(n \log n)$ messages. Ramanathan et al. (Distrib. Comput. 2007) used randomization to improve the message complexity, and showed a randomized algorithm with $O(n)$ messages and $O(\log n)$ time (with failure probability $O(1 / \log^{\Omega(1)}n)$). Our second result is a tightly singularly optimal randomized algorithm, with $O(1)$ time and $O(n)$ messages, for this setting, whose time bound holds with certainty and message bound holds with high probability.

2020: Reactive Pls for Distributed Decision
Abstract: We generalize the definition of Proof Labeling Schemes to reactive systems, that is, systems where the configuration is supposed to keep changing forever. As an example, we address the main classical test case of reactive tasks, namely, the task of token passing. Different RPLSs are given for the cases that the network is assumed to be a tree or an anonymous ring, or a general graph, and the sizes of RPLSs' labels are analyzed. We also address the question of whether an RPLS exists. First, on the positive side, we show that there exists an RPLS for any distributed task for a family of graphs with unique identities. For the case of anonymous networks (even for the special case of rings), interestingly, it is known that no token passing algorithm is possible even if the number n of nodes is known. Nevertheless, we show that an RPLS is possible. On the negative side, we show that if one drops the assumption that n is known, then the construction becomes impossible.

2020: Reactive Proof Labeling Schemes for Distributed Decision
Abstract: We generalize the definition of Proof Labeling Schemes to reactive systems, that is, systems where the configuration is supposed to keep changing forever. As an example, we address the main classical test case of reactive tasks, namely, the task of token passing. Different RPLSs are given for the cases that the network is assumed to be a tree or an anonymous ring, or a general graph, and the sizes of RPLSs' labels are analyzed. We also address the question of whether an RPLS exists. First, on the positive side, we show that there exists an RPLS for any distributed task for a family of graphs with unique identities. For the case of anonymous networks (even for the special case of rings), interestingly, it is known that no token passing algorithm is possible even if the number n of nodes is known. Nevertheless, we show that an RPLS is possible. On the negative side, we show that if one drops the assumption that n is known, then the construction becomes impossible.

2020: Approximating Generalized Network Design under (Dis)economies of Scale with Applications to Energy Efficiency
Abstract: In a generalized network design (GND) problem, a set of resources are assigned (non-exclusively) to multiple requests. Each request contributes its weight to the resources it uses and the total load on a resource is then translated to the cost it incurs via a resource-specific cost function. Motivated by energy efficiency applications, recently, there is a growing interest in GND using cost functions that exhibit (dis)economies of scale ((D)oS), namely, cost functions that appear subadditive for small loads and superadditive for larger loads. The current article advances the existing literature on approximation algorithms for GND problems with (D)oS cost functions in various aspects: (1) while the existing results are restricted to routing requests in undirected graphs, identifying the resources with the graph’s edges, the current article presents a generic approximation framework that yields approximation results for a much wider family of requests (including various types of Steiner tree and Steiner forest requests) in both directed and undirected graphs, where the resources can be identified with either the edges or the vertices; (2) while the existing results assume that a request contributes the same weight to each resource it uses, our approximation framework allows for unrelated weights, thus providing the first non-trivial approximation for the problem of scheduling unrelated parallel machines with (D)oS cost functions; (3) while most of the existing approximation algorithms are based on convex programming, our approximation framework is fully combinatorial and runs in strongly polynomial time; (4) the family of (D)oS cost functions considered in the current article is more general than the one considered in the existing literature, providing a more accurate abstraction for practical energy conservation scenarios; and (5) we obtain the first approximation ratio for GND with (D)oS cost functions that depends only on the parameters of the resources’ technology and does not grow with the number of resources, the number of requests, or their weights. The design of our approximation framework relies heavily on Roughgarden’s smoothness toolbox [43], thus demonstrating the possible usefulness of this toolbox in the area of approximation algorithms.

2020: Invited Paper: Reactive PLS for Distributed Decision
Abstract: None

2020: No-Regret Stateful Posted Pricing
Abstract: In this paper, a rather general online problem called dynamic resource allocation with capacity constraints (DRACC) is introduced and studied in the realm of posted price mechanisms. This problem subsumes several applications of stateful pricing, including but not limited to posted prices for online job scheduling. As the existing online learning techniques do not yield no-regret mechanisms for this problem, we develop a new online learning framework defined over deterministic Markov decision processes with dynamic state transition and reward functions. We then prove that if the Markov decision process is guaranteed to admit a dominant state in each round and there exists an oracle that can switch the internal state with bounded loss, a condition that is satisfied in the DRACC problem, then the online learning problem can be solved with vanishing regret. Our proof technique is based on a reduction to full information online learning with switching cost (Kalai and Vempala, 2005), in which an online decision maker incurs an extra cost every time she switches from one arm to another. We demonstrate this connection formally, and further show how DRACC can be used in our proposed applications of stateful pricing.

2019: Reducing the Number of Messages in Self-stabilizing Protocols
Abstract: None

2019: Hierarchical b-Matching
Abstract: None

