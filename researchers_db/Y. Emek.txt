2024: Decentralized Low-Stretch Trees via Low Diameter Graph Decompositions
Abstract: None

2024: On the Power of Graphical Reconfigurable Circuits
Abstract: We introduce the \emph{graphical reconfigurable circuits (GRC)} model as an abstraction for distributed graph algorithms whose communication scheme is based on local mechanisms that collectively construct long-range reconfigurable channels (this is an extension to general graphs of a distributed computational model recently introduced by Feldmann et al.\ (JCB 2022) for hexagonal grids). The crux of the GRC model lies in its modest assumptions: (1) the individual nodes are computationally weak, with state space bounded independently of any global graph parameter; and (2) the reconfigurable communication channels are highly restrictive, only carrying information-less signals (a.k.a.\ \emph{beeps}). Despite these modest assumptions, we prove that GRC algorithms can solve many important distributed tasks efficiently, i.e., in polylogarithmic time. On the negative side, we establish various runtime lower bounds, proving that for other tasks, GRC algorithms (if they exist) are doomed to be slow.

2024: Barter Exchange with Bounded Trading Cycles
Abstract: Consider a barter exchange problem over a finite set of agents, where each agent owns an item and is also associated with a (privately known) wish list of items belonging to the other agents. An outcome of the problem is a (re)allocation of the items to the agents such that each agent either keeps her own item or receives an item from her (reported) wish list, subject to the constraint that the length of the trading cycles induced by the allocation is up-bounded by a prespecified length bound k. The utility of an agent from an allocation is 1 if she receives an item from her (true) wish list and 0 if she keeps her own item (the agent incurs a large dis-utility if she receives an item that is neither hers nor belongs to her wish list). In this paper, we investigate the aforementioned barter exchange problem from the perspective of mechanism design without money, aiming for truthful (and individually rational) mechanisms whose objective is to maximize the social welfare. As the construction of a social welfare maximizing allocation is computationally intractable for length bounds k \geq 3, this paper focuses on (computationally efficient) truthful mechanisms that approximate the (combinatorially) optimal social welfare.We also study a more general version of the barter exchange problem, where the utility of an agent from participating in a trading cycle of length 2 \leq \ell \leq k is lambda(\ell), where \lambda is a general (monotonically non-increasing) length function. Our results include upper and lower bounds on the guaranteed approximation ratio, expressed in terms of the length bound k and the length function \lambda. On the technical side, our main contribution is an algorithmic tool that can be viewed as a truthful version of the local search paradigm. As it turns out, this tool can be applied to more general (bounded size) coalition formation problems.

2023: Online Algorithms with Randomly Infused Advice
Abstract: We introduce a novel method for the rigorous quantitative evaluation of online algorithms that relaxes the"radical worst-case"perspective of classic competitive analysis. In contrast to prior work, our method, referred to as randomly infused advice (RIA), does not make any probabilistic assumptions about the input sequence and does not rely on the development of designated online algorithms. Rather, it can be applied to existing online randomized algorithms, introducing a means to evaluate their performance in scenarios that lie outside the radical worst-case regime. More concretely, an online algorithm ALG with RIA benefits from pieces of advice generated by an omniscient but not entirely reliable oracle. The crux of the new method is that the advice is provided to ALG by writing it into the buffer B from which ALG normally reads its random bits, hence allowing us to augment it through a very simple and non-intrusive interface. The (un)reliability of the oracle is captured via a parameter 0 {\le} {\alpha} {\le} 1 that determines the probability (per round) that the advice is successfully infused by the oracle; if the advice is not infused, which occurs with probability 1 - {\alpha}, then the buffer B contains fresh random bits (as in the classic online setting). The applicability of the new RIA method is demonstrated by applying it to three extensively studied online problems: paging, uniform metrical task systems, and online set cover. For these problems, we establish new upper bounds on the competitive ratio of classic online algorithms that improve as the infusion parameter {\alpha} increases. These are complemented with (often tight) lower bounds on the competitive ratio of online algorithms with RIA for the three problems.

2023: 14th Innovations in Theoretical Computer Science Conference, ITCS 2023, January 10-13, 2023, MIT, Cambridge, Massachusetts, USA
Abstract: None

2023: On the Runtime of Chemical Reaction Networks Beyond Idealized Conditions
Abstract: This paper studies the (discrete) \emph{chemical reaction network (CRN)} computational model that emerged in the last two decades as an abstraction for molecular programming. The correctness of CRN protocols is typically established under one of two possible schedulers that determine how the execution advances: (1) a \emph{stochastic scheduler} that obeys the (continuous time) Markov process dictated by the standard model of stochastic chemical kinetics; or (2) an \emph{adversarial scheduler} whose only commitment is to maintain a certain fairness condition. The latter scheduler is justified by the fact that the former one crucially assumes ``idealized conditions'' that more often than not, do not hold in real wet-lab experiments. However, when it comes to analyzing the \emph{runtime} of CRN protocols, the existing literature focuses strictly on the stochastic scheduler, thus raising the research question that drives this work: Is there a meaningful way to quantify the runtime of CRNs without the idealized conditions assumption? The main conceptual contribution of the current paper is to answer this question in the affirmative, formulating a new runtime measure for CRN protocols that does not rely on idealized conditions. This runtime measure is based on an adapted (weaker) fairness condition as well as a novel scheme that enables partitioning the execution into short \emph{rounds} and charging the runtime for each round individually (inspired by definitions for the runtime of asynchronous distributed algorithms). Following that, we turn to investigate various fundamental computational tasks and establish (often tight) bounds on the runtime of the corresponding CRN protocols operating under the adversarial scheduler. This includes an almost complete chart of the runtime complexity landscape of predicate decidability tasks.

2022: Deterministic Fault-Tolerant Connectivity Labeling Scheme
Abstract: The f-fault-tolerant connectivity labeling (f-FTC labeling) is a scheme of assigning each vertex and edge with a small-size label such that one can determine the connectivity of two vertices s and t under the presence of at most f faulty edges only from the labels of s, t, and the faulty edges. This paper presents a new deterministic f-FTC labeling scheme attaining O(f2 polylog(n))-bit label size and a polynomial construction time, which settles the open problem left by Dory and Parter [18]. The key ingredient of our construction is to develop a deterministic counterpart of the graph sketch technique by Ahn, Guha, and McGreger [4], via some natural connection with the theory of error-correcting codes. This technique removes one major obstacle in de-randomizing the Dory-Parter scheme. The whole scheme is obtained by combining this technique with a new deterministic graph sparsification algorithm derived from the seminal ϵ-net theory, which is also of independent interest. As byproducts, our result deduces the first deterministic fault-tolerant approximate distance labeling scheme with a non-trivial performance guarantee and an improved deterministic fault-tolerant compact routing. The authors believe that our new technique is potentially useful in the future exploration of more efficient FTC labeling schemes and other related applications based on graph sketches.

2022: Beeping Shortest Paths via Hypergraph Bipartite Decomposition
Abstract: Constructing a shortest path between two network nodes is a fundamental task in distributed computing. This work develops schemes for the construction of shortest paths in randomized beeping networks between a predetermined source node and an arbitrary set of destination nodes. Our first scheme constructs a (single) shortest path to an arbitrary destination in $O (D \log\log n + \log^3 n)$ rounds with high probability. Our second scheme constructs multiple shortest paths, one per each destination, in $O (D \log^2 n + \log^3 n)$ rounds with high probability. Our schemes are based on a reduction of the above shortest path construction tasks to a decomposition of hypergraphs into bipartite hypergraphs: We develop a beeping procedure that partitions the (polynomially-large) hyperedge set of a hypergraph $H = (V_H, E_H)$ into $k = \Theta (\log^2 n)$ disjoint subsets $F_1 \cup \cdots \cup F_k = E_H$ such that the (sub-)hypergraph $(V_H, F_i)$ is bipartite in the sense that there exists a vertex subset $U \subseteq V$ such that $|U \cap e| = 1$ for every $e \in F_i$. This procedure turns out to be instrumental in speeding up shortest path constructions under the beeping model.

2022: Locally Restricted Proof Labeling Schemes (Full Version)
Abstract: Introduced by Korman, Kutten, and Peleg (PODC 2005), a proof labeling scheme (PLS) is a distributed verification system dedicated to evaluating if a given configured graph satisfies a certain property. It involves a centralized prover, whose role is to provide proof that a given configured graph is a yes-instance by means of assigning labels to the nodes, and a distributed verifier, whose role is to verify the validity of the given proof via local access to the assigned labels. In this paper, we introduce the notion of a locally restricted PLS in which the prover's power is restricted to that of a LOCAL algorithm with a polylogarithmic number of rounds. To circumvent inherent impossibilities of PLSs in the locally restricted setting, we turn to models that relax the correctness requirements by allowing the verifier to accept some no-instances as long as they are not"too far"from satisfying the property in question. To this end, we evaluate (1) distributed graph optimization problems (OptDGPs) based on the notion of an approximate proof labeling scheme (APLS) (analogous to the type of relaxation used in sequential approximation algorithms); and (2) configured graph families (CGFs) based on the notion of atesting proof labeling schemes (TPLS) (analogous to the type of relaxation used in property testing algorithms).

2022: Special Issue: Biological Distributed Algorithms 2021
Abstract: None

2022: Design of Self-Stabilizing Approximation Algorithms via a Primal-Dual Approach
Abstract: Self-stabilization is an important concept in the realm of fault-tolerant distributed computing. In this paper, we propose a new approach that relies on the properties of linear programming duality to obtain self-stabilizing approximation algorithms for distributed graph optimization problems. The power of this new approach is demonstrated by the following results: A self-stabilizing 2(1 + ε )-approximation algorithm for minimum weight vertex cover that converges in O (log ∆ / ( ε log log ∆)) synchronous rounds. A self-stabilizing ∆-approximation algorithm for maximum weight independent set that converges in O (∆ + log ∗ n ) synchronous rounds. A self-stabilizing ((2 ρ + 1)(1 + ε ))-approximation algorithm for minimum weight dominating set in ρ -arboricity graphs that converges in O ((log ∆) /ε ) synchronous rounds. In all of the above, ∆ denotes the maximum degree. Our technique improves upon previous results in terms of time complexity while incurring only an additive O (log n ) overhead to the message size. In addition, to the best of our knowledge, we provide the first self-stabilizing algorithms for the weighted versions of minimum vertex cover and maximum independent set.

2021: Multicast Communications with Varying Bandwidth Constraints
Abstract: To find a maximum number of communication requests that can be satisfied concurrently, is a fundamental network scheduling problem. In this work we investigate the problem of finding a maximum number of multicast requests that can be scheduled simultaneously in a tree network in which the edges and links have heterogeneous bandwidth limitations.This problem generalizes two problems studied in the literature: maximum k-colorable subgraph in chordal graphs, maximum multi-commodity flow in trees. The problem is NP-hard and admits a 1.585-approximation in the special case of homogeneous bandwidth limitations.We first show that the problem is harder to approximate when the bandwidth limitations are heterogeneous, i.e. vary from link to link and from node to node. We then generalize of a classical algorithm and obtain an M-approximation where M is the maximum number of leaves of the communication subtrees. Surprisingly, variants of the same algorithm, are used in the literature at least four times to solve related problems. There exists a polynomial-time algorithm for the special case of unicast requests and star topology. We generalize this result and relax the second requirement so that the set of unicast requests share a common vertex with no restriction on the tree topology.

2021: A Thin Self-Stabilizing Asynchronous Unison Algorithm with Applications to Fault Tolerant Biological Networks
Abstract: Introduced by Emek and Wattenhofer (PODC 2013), the stone age (SA) model provides an abstraction for network algorithms distributed over randomized finite state machines. This model, designed to resemble the dynamics of biological processes in cellular networks, assumes a weak communication scheme that is built upon the nodes' ability to sense their vicinity in an asynchronous manner. Recent works demonstrate that the weak computation and communication capabilities of the SA model suffice for efficient solutions to some core tasks in distributed computing, but they do so under the (somewhat less realistic) assumption of fault free computations. In this paper, we initiate the study of self-stabilizing SA algorithms that are guaranteed to recover from any combination of transient faults. Specifically, we develop efficient self-stabilizing SA algorithms for the leader election and maximal independent set tasks in bounded diameter graphs subject to an asynchronous scheduler. These algorithms rely on a novel efficient self-stabilizing asynchronous unison (AU) algorithm that is "thin'' in terms of its state space: the number of states used by the AU algorithm is linear in the graph's diameter bound, irrespective of the number of nodes.

2021: Fully Adaptive Self-Stabilizing Transformer for LCL Problems
Abstract: The first generic self-stabilizing transformer for local problems in a constrained bandwidth model is introduced. This transformer can be applied to a wide class of locally checkable labeling (LCL) problems, converting a given fault free synchronous algorithm that satisfies certain conditions into a self-stabilizing synchronous algorithm for the same problem. The resulting self-stabilizing algorithms are anonymous, size-uniform, and \emph{fully adaptive} in the sense that their time complexity is bounded as a function of the number $k$ of nodes that suffered faults (possibly at different times) since the last legal configuration. Specifically, for graphs whose degrees are up-bounded by $\Delta$, the algorithms produced by the transformer stabilize in time proportional to $\log (k + \Delta)$ in expectation, independently of the number of nodes in the graph. As such, the transformer is applicable also for infinite graphs (with degree bound $\Delta$). Another appealing feature of the transformer is its small message size overhead. The transformer is applied to known algorithms (or simple variants thereof) for some classic LCL problems, producing the first anonymous size-uniform self-stabilizing algorithms for these problems that are provably fully adaptive. From a technical point of view, the transformer's key design feature is a novel probabilistic tool that allows different nodes to act in synchrony even though their clocks may have been adversarially manipulated.

2020: Online Paging with a Vanishing Regret
Abstract: This paper considers a variant of the online paging problem, where the online algorithm has access to multiple predictors, each producing a sequence of predictions for the page arrival times. The predictors may have occasional prediction errors and it is assumed that at least one of them makes a sublinear number of prediction errors in total. Our main result states that this assumption suffices for the design of a randomized online algorithm whose time-average regret with respect to the optimal offline algorithm tends to zero as the time tends to infinity. This holds (with different regret bounds) for both the full information access model, where in each round, the online algorithm gets the predictions of all predictors, and the bandit access model, where in each round, the online algorithm queries a single predictor. 
While online algorithms that exploit inaccurate predictions have been a topic of growing interest in the last few years, to the best of our knowledge, this is the first paper that studies this topic in the context of multiple predictors. Moreover, to the best of our knowledge, this is also the first paper that aims for (and achieves) online algorithms with a vanishing regret for a classic online problem under reasonable assumptions.

2020: A Tight Lower Bound for the Capture Time of the Cops and Robbers Game
Abstract: For the game of Cops and Robbers, it is known that in 1-cop-win graphs, the cop can capture the robber in O(n) time, and that there exist graphs in which this capture time is tight. When k >= 2, a simple counting argument shows that in k-cop-win graphs, the capture time is at most O(n^{k + 1}), however, no non-trivial lower bounds were previously known; indeed, in their 2011 book, Bonato and Nowakowski ask whether this upper bound can be improved. In this paper, the question of Bonato and Nowakowski is answered on the negative, proving that the O(n^{k + 1}) bound is asymptotically tight for any constant k >= 2. This yields a surprising gap in the capture time complexities between the 1-cop and the 2-cop cases.

2020: Efficient Self-Stabilizing Leader Election ( Full Version ) ∗
Abstract: This paper presents a randomized self-stabilizing algorithm that elects a leader r in a general n-node undirected graph and constructs a spanning tree T rooted at r. The algorithm works under the synchronous message passing network model, assuming that the nodes know a linear upper bound on n and that each edge has a unique ID known to both its endpoints (or, alternatively, assuming the KT1 model). The highlight of this algorithm is its superior communication efficiency: It is guaranteed to send a total of Õ(n) messages, each of constant size, till stabilization, while stabilizing in Õ(n) rounds, in expectation and with high probability. After stabilization, the algorithm sends at most one constant size message per round while communicating only over the (n− 1) edges of T . In all these aspects, the communication overhead of the new algorithm is far smaller than that of the existing (mostly deterministic) self-stabilizing leader election algorithms. The algorithm is relatively simple and relies mostly on known modules that are common in the fault free leader election literature; these modules are enhanced in various subtle ways in order to assemble them into a communication efficient self-stabilizing algorithm.

2020: Reinforcement Learning Enables Resource Partitioning in Foraging Bats
Abstract: None

2020: Approximating Generalized Network Design under (Dis)economies of Scale with Applications to Energy Efficiency
Abstract: In a generalized network design (GND) problem, a set of resources are assigned (non-exclusively) to multiple requests. Each request contributes its weight to the resources it uses and the total load on a resource is then translated to the cost it incurs via a resource-specific cost function. Motivated by energy efficiency applications, recently, there is a growing interest in GND using cost functions that exhibit (dis)economies of scale ((D)oS), namely, cost functions that appear subadditive for small loads and superadditive for larger loads. The current article advances the existing literature on approximation algorithms for GND problems with (D)oS cost functions in various aspects: (1) while the existing results are restricted to routing requests in undirected graphs, identifying the resources with the graph’s edges, the current article presents a generic approximation framework that yields approximation results for a much wider family of requests (including various types of Steiner tree and Steiner forest requests) in both directed and undirected graphs, where the resources can be identified with either the edges or the vertices; (2) while the existing results assume that a request contributes the same weight to each resource it uses, our approximation framework allows for unrelated weights, thus providing the first non-trivial approximation for the problem of scheduling unrelated parallel machines with (D)oS cost functions; (3) while most of the existing approximation algorithms are based on convex programming, our approximation framework is fully combinatorial and runs in strongly polynomial time; (4) the family of (D)oS cost functions considered in the current article is more general than the one considered in the existing literature, providing a more accurate abstraction for practical energy conservation scenarios; and (5) we obtain the first approximation ratio for GND with (D)oS cost functions that depends only on the parameters of the resources’ technology and does not grow with the number of resources, the number of requests, or their weights. The design of our approximation framework relies heavily on Roughgarden’s smoothness toolbox [43], thus demonstrating the possible usefulness of this toolbox in the area of approximation algorithms.

2020: Stateful Posted Pricing with Vanishing Regret via Dynamic Deterministic Markov Decision Processes
Abstract: An online problem called dynamic resource allocation with capacity constraints (DRACC) is introduced and studied in the realm of posted price mechanisms. This problem subsumes several applications of stateful pricing, including but not limited to posted prices for online job scheduling and matching over a dynamic bipartite graph. Because existing online learning techniques do not yield vanishing regret for this problem, we develop a novel online learning framework over deterministic Markov decision processes with dynamic state transition and reward functions. Following that, we prove, based on a reduction to the well-studied problem of online learning with switching costs, that if the Markov decision process admits a chasing oracle (i.e., an oracle that simulates any given policy from any initial state with bounded loss), then the online learning problem can be solved with vanishing regret. Our results for the DRACC problem and its applications are then obtained by devising (randomized and deterministic) chasing oracles that exploit the particular structure of these problems. Funding: The work of Y. Emek was supported in part by the Israel Science Foundation [Grant 1016/17]. The work of R. Lavi was partially supported by the Israel Science Foundation [Grant 2560/17] and the National Natural Science Foundation of China [Grant 2560/17]. The work of R. Niazadeh was supported by the University of Chicago Booth School of Business. The work of Y. Shi was partially supported at the Technion by the Council for Higher Education [fellowship], and at Shandong University by the Science Fund Program of Shandong Province for Distinguished Oversea Young Scholars [Grant 2023HWYQ-006].

