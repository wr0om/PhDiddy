Recent papers for Yakir Vizel:

2025: Revisiting DRUP-based Interpolants with CaDiCaL 2.0
Abstract: We present our implementation of DRUP-based interpolants in CaDiCaL 2.0, and evaluate performance in the bit-level model checker Avy using the Hardware Model Checking Competition benchmarks. CaDiCaL is a state-of-the-art, open-source SAT solver known for its efficiency and flexibility. In its latest release, version 2.0, CaDiCaL introduces a new proof tracer API. This paper presents a tool that leverages this API to implement the DRUP-based algorithm for generating interpolants. By integrating this algorithm into CaDiCaL, we enable its use in model-checking workflows that require interpolants. Our experimental evaluation shows that integrating CaDiCaL with DRUP-based interpolants in Avy results in better performance (both runtime and number of solved instances) when compared to Avy with Glucose as the main SAT solver. Our implementation is publicly available and can be used by the formal methods community to further develop interpolation-based algorithms using the state-of-the-art SAT solver CaDiCaL. Since our implementation uses the Tracer API, it should be maintainable and applicable to future releases of CaDiCaL.

2023: Automatic and Incremental Repair for Speculative Information Leaks
Abstract: We present CureSpec, the first model-checking based framework for automatic repair of programs with respect to information leaks in the presence of side-channels and speculative execution. CureSpec is based on formal models of attacker capabilities, including observable side channels, inspired by the Spectre attacks. For a given attacker model, CureSpec is able to either prove that the program is secure, or detect potential side-channel vulnerabilities and automatically insert mitigations such that the resulting code is provably secure. Moreover, CureSpec can provide a certificate for the security of the program that can be independently checked. We have implemented CureSpec in the SeaHorn framework and show that it can effectively repair security-critical code, for example the AES encryption from the OpenSSL library.

2023: Condition Synthesis Realizability via Constrained Horn Clauses
Abstract: None

2023: Hyperproperty Verification as CHC Satisfiability
Abstract: Hyperproperties govern the behavior of a system or systems across multiple executions, and are being recognized as an important extension of regular temporal properties. So far, such properties have resisted comprehensive treatment by modern software model-checking approaches such as IC3/PDR, due to the need to find not only an inductive invariant but also a \emph{total} alignment of different executions that facilitates simpler inductive invariants. We show how this treatment is achieved via a reduction from the verification problem of $\forall^k\exists^l$ properties to Constrained Horn Clauses. The approach is based on combining the inference of an alignment and inductive invariant in a single CHC encoding; and, for existential quantification over traces, incorporating also inference of a witness function for the existential choices, based on a game semantics with a sound-and-complete encoding to CHCs as well.

2023: Structure-Guided Solution of Constrained Horn Clauses
Abstract: None

2022: Bounded Model Checking for LLVM
Abstract: Bounded Model Checking (BMC) is an effective and precise static analysis technique that reduces program verification to satisfiability (SAT) solving. In this paper, we present the design and implementation of a new BMC engine (SEABMC) in the SEAHORN verification framework for LLVM. SeaBmc precisely models arithmetic, pointer, and memory operations of LLVM. Our key design innovation is to structure verification condition generation around a series of transformations, starting with a custom IR (called SEA-IR) that explicitly purifies all memory operations by explicating dependencies between them. This transformation-based approach enables supporting many different styles of verification conditions. To support memory safety checking, we extend our base approach with fat pointers and shadow bits of memory to keep track of metadata, such as the size of a pointed-to object. To evaluate SeaBmc, we have used it to verify aws-c-common library from AWS. We report on the effect of different encoding options with different SMT solvers, and also compare with CBMC, SMACK, KLEE and Symbiotic. We show that SeaBmc is capable of providing order of magnitude improvement compared with state-of-the-art.

2021: Verifying verified code
Abstract: None

2021: IC3 with Internal Signals
Abstract: IC3 is a highly-effective algorithm for formal hardware verification. It cleverly uses a SAT solver to compute an inductive invariant, an over-approximation of reachable states, of a hardware design. The invariant is computed in CNF as a conjunction of lemmas. This CNF representation over state variables, although efficient, leads to an obvious deficiency: IC3 is not effective for designs that do not have a concise CNF invariant over state variables. We show how to remedy this deficiency by extending traditional IC3 to learn invariants not only in terms of state variables, but also in terms of internal signals of the design. Our proposed method can learn significantly more compact invariants than IC3, while maintaining a highly-efficient CNF representation. We evaluate our technique on several industrial sequential equivalence checking (SEC) problems from IBM, SEC problems derived from designs in the Hardware Model Checking Competition (HWMCC) and SEC problems from academia. In addition, we evaluate it on HWMCC benchmarks. IC3 with internal signals is efficient for SEC and outperforms traditional IC3 on an important class of benchmarks.

2019: Interpolating Strong Induction
Abstract: None

2019: Property Directed Self Composition
Abstract: None

2019: Efficient Information-Flow Verification Under Speculative Execution
Abstract: None

2018: Discovering Universally Quantified Solutions for Constrained Horn Clauses
Abstract: The logic of Constrained Horn Clauses (CHC) provides an e ective logical characterization of many problems in (software) veri cation. For example, CHC naturally capture inductive invariant discovery for sequential programs [4], compositional veri cation of concurrent and distributed systems [15, 19, 17], and veri cation of program equivalence [11]. CHC is used as an intermediate representation by several state-of-the-art program analysis tools, including SeaHorn [16] and JayHorn [20]. IC3 [6], initially introduced for model checking of nite state transition systems, has become the dominant model checking algorithm for hardware veri cation. Even more impressively, the IC3 framework (i.e., many algorithms built in the style of IC3) has become the dominant framework for exploring and building SAT/SMT-based veri cation algorithms. In particular, the framework has been extended to CHC modulo SMT theories in [7, 18, 8, 23, 3, 22, 21, 9]. The e ciency of IC3 for software veri cation is demonstrated by the e ectiveness of such tools as SeaHorn. However, current extensions of IC3 are limited either in supported theories (e.g., no arithmetic), shape of the solution (i.e., quanti er free), or are not fully integrated within the IC3 framework. In this work, we extend the IC3 framework to discovering universally quanti ed solutions to CHC. In the case that CHC are applied to software veri cation, these solutions correspond to universally quanti ed inductive invariants. This extends applicability of the framework, in particular, to reasoning about array manipulating programs and compositional veri cation of distributed protocols that require quanti ed invariants to reference arbitrary array locations and arbitrary processes. Constrained Horn Clauses (CHC) is a fragment of First Order Logic (FOL) in which a formula is a conjunction of clauses, where each clause is a universally quanti ed formula of the form: ∀~x · p1(~x) ∧ · · · ∧ pl(~x) ∧ φ ⇒ p0(~x), where each pi is an uninterpreted predicate, and φ is a constraint over interpreted predicates and functions of some background theory T . A set Φ of CHC is satis able modulo theory T if and only if there is a rst order model that satis es every clause of Φ and is consistent with the background theory T . A symbolic solution Ψ to a set of CHC Φ is a map from each predicate pi to a FOL formula ψ(pi) such that Φ[pi 7→ ψ(pi)] is a valid sentence in T . That is, ψ(pi) is a symbolic representation of a model for pi. We consider CHC where the constraints are in the combined theory of Linear Integer Arithmetic (LIA) and Arrays. In many cases, solutions to such systems are de nable by universally quanti ed formulas over the background theory. For example, de ning that an array A is lled with 0 requires a quanti ed formula ∀i ·A [i] = 0. Quanti ers introduce two major challenges: (i) they tremendously increase the search space for a candidate solution, and (ii) they require deciding satis ability of quanti ed formulas itself an undecidable problem.

2018: Quantifiers on Demand
Abstract: None

2018: Instruction-Level Abstraction (ILA)
Abstract: Modern Systems-on-Chip (SoC) designs are increasingly heterogeneous and contain specialized semi-programmable accelerators in addition to programmable processors. In contrast to the pre-accelerator era, when the ISA played an important role in verification by enabling a clean separation of concerns between software and hardware, verification of these “accelerator-rich” SoCs presents new challenges. From the perspective of hardware designers, there is a lack of a common framework for formal functional specification of accelerator behavior. From the perspective of software developers, there exists no unified framework for reasoning about software/hardware interactions of programs that interact with accelerators. This article addresses these challenges by providing a formal specification and high-level abstraction for accelerator functional behavior. It formalizes the concept of an Instruction Level Abstraction (ILA), developed informally in our previous work, and shows its application in modeling and verification of accelerators. This formal ILA extends the familiar notion of instructions to accelerators and provides a uniform, modular, and hierarchical abstraction for modeling software-visible behavior of both accelerators and programmable processors. We demonstrate the applicability of the ILA through several case studies of accelerators (for image processing, machine learning, and cryptography), and a general-purpose processor (RISC-V). We show how the ILA model facilitates equivalence checking between two ILAs, and between an ILA and its hardware finite-state machine (FSM) implementation. Further, this equivalence checking supports accelerator upgrades using the notion of ILA compatibility, similar to processor upgrades using ISA compatibility.

2018: Template-Based Parameterized Synthesis of Uniform Instruction-Level Abstractions for SoC Verification
Abstract: Modern system-on-chip (SoC) designs comprise programmable cores, application-specific accelerators, and I/O devices. Accelerators are controlled by software/firmware and functionality is implemented by this combination of programmable cores, firmware, and accelerators. Verification of such SoCs is challenging, especially for system-level properties maintained by a combination of firmware and hardware. Attempting to formally verify the full SoC design with both firmware and hardware is not scalable, while separate verification can miss bugs. A general technique for scalable system-level verification is to construct an abstraction of SoC hardware and verify firmware/software using it. There are two challenges in applying this technique in practice. Constructing the abstraction to capture required details and interactions is error-prone and time-consuming. The second is ensuring abstraction correctness so that properties proven with it are valid. This paper introduces a methodology for SoC design and verification based on the synthesis of instruction-level abstractions (ILAs). The ILA is an abstraction of SoC hardware which models updates to firmware-visible state at the granularity of instructions. For hardware accelerators, the ILA is analogous to the instruction-set architecture definition for programmable processors and enables scalable verification of firmware interacting with hardware accelerators. To alleviate the disadvantages of manual construction of abstractions, we introduce two algorithms for synthesis of ILAs from partial description called templates. We then show how the ILA can be verified to be correct. We evaluate the methodology using a small SoC design consisting of the 8051 microcontroller and two cryptographic accelerators. The methodology uncovered 15 bugs.

2018: Lazy Self-composition for Security Verification
Abstract: None

2017: Solving Constraints over Bit-Vectors with SAT-based Model Checking
Abstract: None

2017: PPU
Abstract: With increasing technology scaling and design complexity there are increasing threats from device and circuit failures. This is expected to worsen with post-CMOS devices. Current error-resilient solutions ensure reliability of circuits through protection mechanisms such as redundancy, error correction, and recovery. However, the costs of these solutions may be high, rendering them impractical. In contrast, error-tolerant solutions allow errors in the computation and are positioned to be suitable for error-tolerant applications such as media applications. For such programmable error-tolerant processors, the Instruction-Set-Architecture (ISA) no longer serves as a specification since it is acceptable for the processor to allow for errors during the execution of instructions. In this work, we address this specification gap by defining the basic requirements needed for an error-tolerant processor to provide acceptable results. Furthermore, we formally define properties that capture these requirements. Based on this, we propose the Partially Protected Uniprocessor (PPU), an error-tolerant processor that aims to meet these requirements with low-cost microarchitectural support. These protection mechanisms convert potentially fatal control errors to potentially tolerable data errors instead of ensuring instruction-level or byte-level correctness. The protection mechanisms in PPU protect the system against crashes, unresponsiveness, and external device corruption. In addition, they also provide support for achieving acceptable result quality. Additionally, we provide a methodology that formally proves the specification properties on PPU using model checking. This methodology uses models for the hardware and software that are integrated with the fault and recovery models. Finally, we experimentally demonstrate the results of model checking and the application-level quality of results for PPU.

2017: Solving linear arithmetic with SAT-based model checking
Abstract: We present LIAMC, a novel decision procedure for (quantifier-free) linear arithmetic over both integers modulo 2N (LIAn) and integers (LIA). There is no need to explain our motivation to design a new efficient decision procedure for the widely used LIA logic. A LIAn decision procedure can be extremely useful in the context of software (SW) verification. SW verification usually requires to reason about arithmetic constraints over finite integers. To that end, modern SW verification tools commonly use fixed-width bit-vector (BV) solvers. However, BV solvers' efficiency drops dramatically as the width increases. To solve the performance problem, LIA solvers are applied, but they are imprecise as they cannot handle integer overflow. An efficient LIAN solver would be the ideal solution in this context. Our decision procedure LIAMC is based on a transformation of linear arithmetic into safety verification. We treat integers as unbounded streams of bits over time. More precisely, for each input integer, the least significant bit (LSB) corresponds to time 0 in the corresponding stream, and the k-th bit corresponds to the bit received at time k. LIAMC then uses SAT-based model checking (SATMC) to solve the resulting problem. In order to achieve efficiency, LIAMC uses two forms of generalization. First, if it finds a formula to be unsatisfiable for width N, it tries to generalize this result for all the widths. Second, if LIAMC finds a formula to be satisfiable for width N, it tries to “extend” and thus generalize the assignment to a wider target width. To evaluate LIAMC we used the QF_LIA subset of SMT-COMP'16, and ran two sets of experiments. First, we reinterpreted the QF_LIA over fixed-width bit-vectors of varying widths and compared LIAMC in LIAn mode to both Boolector and Z3. LIAMC solved the most satisfiable instances out of the three even for the shortest width 32. Second, we compared LIAMC to CVC4 and Z3 on the original QF_LIA benchmarks. LIAMC was able to solve many instances that had not been solved by the other solvers.

2017: IC3 - Flipping the E in ICE
Abstract: None

